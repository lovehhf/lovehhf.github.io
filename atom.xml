<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>晨飞小窝</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.ichenfei.com/"/>
  <updated>2019-11-30T09:06:21.484Z</updated>
  <id>http://blog.ichenfei.com/</id>
  
  <author>
    <name>lovehhf</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【算法学习】AcWing 899. 编辑距离(dp)</title>
    <link href="http://blog.ichenfei.com/2019/11/30/%E3%80%90%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E3%80%91AcWing%20899.%20%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E3%80%90dp%E3%80%91/"/>
    <id>http://blog.ichenfei.com/2019/11/30/%E3%80%90%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E3%80%91AcWing%20899.%20%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E3%80%90dp%E3%80%91/</id>
    <published>2019-11-30T07:00:02.000Z</published>
    <updated>2019-11-30T09:06:21.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AcWing-902-最短编辑距离"><a href="#AcWing-902-最短编辑距离" class="headerlink" title="AcWing 902. 最短编辑距离"></a><a href="https://www.acwing.com/problem/content/904/" target="_blank" rel="noopener">AcWing 902. 最短编辑距离</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定两个字符串A和B，现在要将A经过若干操作变为B，可进行的操作有：<br>删除–将字符串A中的某个字符删除。<br>插入–在字符串A的某个位置插入某个字符。<br>替换–将字符串A中的某个字符替换为另一个字符。<br>现在请你求出，将A变为B至少需要进行多少次操作。</p><a id="more"></a><p><strong>输入格式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一行包含整数n，表示字符串A的长度。</span><br><span class="line">第二行包含一个长度为n的字符串A。</span><br><span class="line">第三行包含整数m，表示字符串B的长度。</span><br><span class="line">第四行包含一个长度为m的字符串B。</span><br><span class="line">字符串中均只包含大写字母。</span><br></pre></td></tr></table></figure></p><p><strong>输出格式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一个整数，表示最少操作次数。</span><br></pre></td></tr></table></figure></p><p><strong>数据范围</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1≤n,m≤1000</span><br></pre></td></tr></table></figure></p><p><strong>输入样例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10 </span><br><span class="line">AGTCTGACGC</span><br><span class="line">11 </span><br><span class="line">AGTAAGTAGGC</span><br></pre></td></tr></table></figure></p><p><strong>输出样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>二维dp问题</p><ul><li>状态表示:<ul><li><code>dp[i][j]</code>表示第一个字符串的前i个字母编辑到第二个字符串的前j个字母的最小编辑距离</li></ul></li><li>状态计算:<ul><li>枚举字符串a前i个字母到字符串b前j个字母的最后一步的操作(增/删/改)</li><li>添加一个字母:<ul><li>要先做到<code>a的前i个字母与b的前j - 1个字母匹配</code>, a[1~i]添加一个字母才能与b[1~j]匹配</li><li><code>dp[i][j] = dp[i - 1][j] + 1</code></li></ul></li><li>删除一个字母:<ul><li>要先做到<code>a的前i - 1个字母与b的前j个字母匹配</code>，a[1~i]添加一个字母才能与b[1~j]匹配</li><li><code>dp[i][j] = dp[i][j - 1] + 1</code></li></ul></li><li>修改一个字母<ul><li>要先做到a[1~i-1]与b[1~j-1]匹配</li><li>a[i]与b[j]相同: <code>dp[i][j] = dp[i - 1][j - 1]</code></li><li>a[i]与b[j]不同: <code>dp[i][j] = dp[i - 1][j - 1] + 1</code></li></ul></li><li>状态转移方程：<ul><li><code>dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + (a[i] != b[j]))</code></li></ul></li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> a[N], b[N];</span><br><span class="line"><span class="comment">// f[i][j]表示A[1~i]到B[1~j]最小的编辑距离</span></span><br><span class="line"><span class="keyword">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        f[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">        f[<span class="number">0</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 枚举最后一步的编辑方式(添加/删除/修改), 取最小值</span></span><br><span class="line">            f[i][j] = min(f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            f[i][j] = min(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="keyword">int</span>(a[i] != b[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python"><a href="#Python" class="headerlink" title="Python:"></a>Python:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    n = int(input())</span><br><span class="line">    a = <span class="string">' '</span>+ input()</span><br><span class="line">    m = int(input())</span><br><span class="line">    b = <span class="string">' '</span> + input()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    f = [[<span class="number">0</span>] * (m + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        f[i][<span class="number">0</span>] = i</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">        f[<span class="number">0</span>][i] = i</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 取三种操作的最小值</span></span><br><span class="line">            f[i][j] = min(f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>, f[i - <span class="number">1</span>][j - <span class="number">1</span>] + (a[i] != b[j]))</span><br><span class="line">            </span><br><span class="line">    print(f[n][m])</span><br><span class="line">    </span><br><span class="line">main()</span><br></pre></td></tr></table></figure><hr><h2 id="AcWing-899-编辑距离"><a href="#AcWing-899-编辑距离" class="headerlink" title="AcWing 899. 编辑距离"></a><a href="https://www.acwing.com/problem/content/901/" target="_blank" rel="noopener">AcWing 899. 编辑距离</a></h2><p>给定n个长度不超过10的字符串以及m次询问，每次询问给出一个字符串和一个操作次数上限。</p><p>对于每次询问，请你求出给定的n个字符串中有多少个字符串可以在上限操作次数内经过操作变成询问给出的字符串。</p><p>每个对字符串进行的单个字符的插入、删除或替换算作一次操作。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数n和m。</p><p>接下来n行，每行包含一个字符串，表示给定的字符串。</p><p>再接下来m行，每行包含一个字符串和一个整数，表示一次询问。</p><p>字符串中只包含小写字母，且长度均不超过10。</p><p><strong>输出格式</strong></p><p>输出共m行，每行输出一个整数作为结果，表示一次询问中满足条件的字符串个数。</p><p><strong>数据范围</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1≤n,m≤1000,</span><br></pre></td></tr></table></figure><p><strong>输入样例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">abc</span><br><span class="line">acd</span><br><span class="line">bcd</span><br><span class="line">ab 1</span><br><span class="line">acbd 2</span><br></pre></td></tr></table></figure></p><p><strong>输出样例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>最短编辑距离的应用, 求n次最短编辑距离</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><h4 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, M = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> s[N][M];</span><br><span class="line"><span class="keyword">int</span> f[M][M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// a是否能在&lt;=t的次数下编辑到b</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">can_solve</span><span class="params">(<span class="keyword">char</span> a[], <span class="keyword">char</span> b[], <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> la = <span class="built_in">strlen</span>(a + <span class="number">1</span>), lb = <span class="built_in">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= la; i++) f[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lb; i++) f[<span class="number">0</span>][i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求a最小需要编辑多少次可以到b</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= la; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lb; j++) &#123;</span><br><span class="line">            f[i][j] = min(f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            f[i][j] = min(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="keyword">int</span>(a[i] != b[j]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f[la][lb] &lt;= t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; s[i] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(m --) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="keyword">char</span> q[M];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q + <span class="number">1</span> &gt;&gt; t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) res += can_solve(s[j], q, t);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">can_solve</span><span class="params">(a, b, t)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    求字符串a是否能在t的次数内编辑到b</span></span><br><span class="line"><span class="string">    为了方便计算, a和b在前面随便加个字符占位</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    a = <span class="string">' '</span> + a</span><br><span class="line">    b = <span class="string">' '</span> + b</span><br><span class="line">    la, lb = len(a), len(b)</span><br><span class="line">    dp = [[<span class="number">0</span>] * lb <span class="keyword">for</span> _ <span class="keyword">in</span> range(la)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化：a[i]到空字符串的编辑距离为i, 空字符串到b[i]的编辑距离也是i</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(la):</span><br><span class="line">        dp[i][<span class="number">0</span>] = i</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(lb):</span><br><span class="line">        dp[<span class="number">0</span>][i] = i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, la):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, lb):</span><br><span class="line">            <span class="comment"># dp[i][j]: a的前i个字母到b的前j个字母的最短编辑距离</span></span><br><span class="line">            <span class="comment"># 枚举最后一步的编辑方式: 增 dp[i - 1][j] + 1, 删 dp[i][j - 1] + 1, 改dp[i - 1][j - 1] + 1</span></span><br><span class="line">            <span class="comment"># 如果a[i] == b[j] 不需要编辑, 直接是dp[i - 1][j - 1]</span></span><br><span class="line">            dp[i][j] = min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + (a[i] != b[j]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[la - <span class="number">1</span>][lb - <span class="number">1</span>] &lt;= t</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    n, m = [int(x) <span class="keyword">for</span> x <span class="keyword">in</span> input().split()]</span><br><span class="line">    s = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">        s.append(input())</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(m):</span><br><span class="line">        q, t = input().split()</span><br><span class="line">        t = int(t)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            res += can_solve(s[i], q, t)</span><br><span class="line">        print(res)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;AcWing-902-最短编辑距离&quot;&gt;&lt;a href=&quot;#AcWing-902-最短编辑距离&quot; class=&quot;headerlink&quot; title=&quot;AcWing 902. 最短编辑距离&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.acwing.com/problem/content/904/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AcWing 902. 最短编辑距离&lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;给定两个字符串A和B，现在要将A经过若干操作变为B，可进行的操作有：&lt;br&gt;删除–将字符串A中的某个字符删除。&lt;br&gt;插入–在字符串A的某个位置插入某个字符。&lt;br&gt;替换–将字符串A中的某个字符替换为另一个字符。&lt;br&gt;现在请你求出，将A变为B至少需要进行多少次操作。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="算法学习" scheme="http://blog.ichenfei.com/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="dp" scheme="http://blog.ichenfei.com/tags/dp/"/>
    
      <category term="编辑距离" scheme="http://blog.ichenfei.com/tags/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>hexo deploy配置免输入github账号密码</title>
    <link href="http://blog.ichenfei.com/2019/11/24/hexo-deploy%E9%85%8D%E7%BD%AE%E5%85%8D%E8%BE%93%E5%85%A5github%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81/"/>
    <id>http://blog.ichenfei.com/2019/11/24/hexo-deploy%E9%85%8D%E7%BD%AE%E5%85%8D%E8%BE%93%E5%85%A5github%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81/</id>
    <published>2019-11-24T07:42:27.000Z</published>
    <updated>2019-11-30T10:09:35.406Z</updated>
    
    <content type="html"><![CDATA[<p>每次hexo d都要输入密码太烦了</p><a id="more"></a><h3 id="生成ssh密钥对"><a href="#生成ssh密钥对" class="headerlink" title="生成ssh密钥对"></a>生成ssh密钥对</h3><p>Linux系统:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>Windows可以使用Xshell生成秘钥对, 之后导入到 <code>C:\Users\Username\.ssh</code>目录下</p><p>公钥命名为<code>id_rsa.pub</code>, 私钥命名为<code>id_rsa</code></p><h3 id="github添加ssh公钥"><a href="#github添加ssh公钥" class="headerlink" title="github添加ssh公钥"></a>github添加ssh公钥</h3><p>方法一: 在个人profile里添加公钥</p><p><code>Your profile</code> -&gt; <code>SSH and GPG keys</code> -&gt; <code>New SSH key</code> -&gt; 复制生成的公钥 -&gt; </p><p>方法二: 项目的设置里面添加</p><p><code>Settings</code> -&gt;  <code>Deploy keys</code> -&gt; <code>Add Deploy key</code> -&gt; 复制公钥 -&gt; 勾选<code>Allow write access</code> -&gt; <code>Add new</code></p><h3 id="设置远程git地址："><a href="#设置远程git地址：" class="headerlink" title="设置远程git地址："></a>设置远程git地址：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog/.deploy_git</span><br><span class="line">git remote rm origin</span><br><span class="line">git remote <span class="built_in">set</span>-url origin git@github.com:lovehhf/lovehhf.github.io.git</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git remote -v   <span class="comment"># 查看当前传输协议</span></span><br><span class="line">origin    git@github.com:lovehhf/lovehhf.github.io.git (fetch)</span><br><span class="line">origin    git@github.com:lovehhf/lovehhf.github.io.git (push)</span><br></pre></td></tr></table></figure><p>编辑配置文件<code>_config.yml</code>, 将<code>deploy</code>的<code>https</code>协议改为使用<code>git</code>协议:</p><p>vim _config.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repository:</span> <span class="string">git@github.com:lovehhf/lovehhf.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>部署到github: <code>hexo d -g</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每次hexo d都要输入密码太烦了&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>树莓派配置v2ray客户端</title>
    <link href="http://blog.ichenfei.com/2019/11/24/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8v2ray%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <id>http://blog.ichenfei.com/2019/11/24/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8v2ray%E5%AE%A2%E6%88%B7%E7%AB%AF/</id>
    <published>2019-11-24T05:06:03.000Z</published>
    <updated>2019-11-24T08:38:31.414Z</updated>
    
    <content type="html"><![CDATA[<p>git用起来太慢了, 几乎不能用 , ss又经常被封端口, 并不是很稳, 使用最近很流行的v2ray试试</p><a id="more"></a><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>使用一键安装脚本安装，参考<img src="https://www.v2ray.com/chapter_00/install.html" alt="v2ray官方教程-下载安装"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bash &lt;(curl -L -s https://install.direct/go.sh)</span><br></pre></td></tr></table></figure><p>需要从github下载安装包, 可能会出现网络错误, 可能先从<a href="https://github.com/v2ray/v2ray-core/releases" target="_blank" rel="noopener">v2ray-core/releases</a>将安装包<code>v2ray-linux-arm.zip</code>下载到树莓派, 使用<code>--local</code>参数从本地安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget -O v2ray_install.sh  https://install.direct/go.sh</span><br><span class="line">chmod +x v2ray_install.sh </span><br><span class="line">sudo ./v2ray_install.sh --<span class="built_in">local</span> v2ray-linux-arm.zip</span><br></pre></td></tr></table></figure><h2 id="配置v2ray客户端"><a href="#配置v2ray客户端" class="headerlink" title="配置v2ray客户端"></a>配置v2ray客户端</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">sudo su - root</span><br><span class="line">cat &gt; /etc/v2ray/config.json &lt;&lt; EOF</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"inbounds"</span>: [&#123;</span><br><span class="line">    <span class="string">"port"</span>: 1080,</span><br><span class="line">    <span class="string">"listen"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"socks"</span>,</span><br><span class="line">    <span class="string">"settings"</span>: &#123;</span><br><span class="line">      <span class="string">"udp"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="string">"outbounds"</span>: [&#123;</span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">    <span class="string">"settings"</span>: &#123;</span><br><span class="line">      <span class="string">"vnext"</span>: [&#123;</span><br><span class="line">        <span class="string">"address"</span>: <span class="string">"server ip"</span>,</span><br><span class="line">        <span class="string">"port"</span>: 10086,</span><br><span class="line">        <span class="string">"users"</span>: [&#123; <span class="string">"id"</span>: <span class="string">"b831381d-6324-4d53-ad4f-8cda48b30811"</span> &#125;]</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    <span class="string">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">    <span class="string">"tag"</span>: <span class="string">"direct"</span>,</span><br><span class="line">    <span class="string">"settings"</span>: &#123;&#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  <span class="string">"routing"</span>: &#123;</span><br><span class="line">    <span class="string">"domainStrategy"</span>: <span class="string">"IPOnDemand"</span>,</span><br><span class="line">    <span class="string">"rules"</span>: [&#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"field"</span>,</span><br><span class="line">      <span class="string">"ip"</span>: [<span class="string">"geoip:private"</span>],</span><br><span class="line">      <span class="string">"outboundTag"</span>: <span class="string">"direct"</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment"># address改为服务端ip， port改为服务端端口, id改为服务端用户ID</span></span><br></pre></td></tr></table></figure><h2 id="开启v2ray服务"><a href="#开启v2ray服务" class="headerlink" title="开启v2ray服务"></a>开启v2ray服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start v2ray</span><br><span class="line">pi@raspberrypi:~ $ ps -ef|grep v2ray</span><br><span class="line">root     18007     1  0 14:20 ?        00:00:00 /usr/bin/v2ray/v2ray -config /etc/v2ray/config.json</span><br></pre></td></tr></table></figure><h2 id="使用ProxyChains-NG配置全局代理"><a href="#使用ProxyChains-NG配置全局代理" class="headerlink" title="使用ProxyChains-NG配置全局代理"></a>使用ProxyChains-NG配置全局代理</h2><p>切换到root用户编译安装proxychains-ng</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/rofl0r/proxychains-ng.git  </span><br><span class="line">sudo su - root</span><br><span class="line"><span class="built_in">cd</span> /home/pi/proxychains-ng-master/</span><br><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>添加配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cp ./src/proxychains.conf /etc/proxychains.conf</span><br><span class="line"></span><br><span class="line">vim /etc/proxychains.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将最后的 socks4 127.0.0.1 9095 改为 socks5  127.0.0.1 9050</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> <span class="comment"># 退出root用户</span></span><br></pre></td></tr></table></figure><p>在需要使用代理的命令前面加上<code>proxychains4</code>, 如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~/proxychains-ng-master $ curl ip.sb</span><br><span class="line">113.xxx.xxx.xxx</span><br><span class="line">pi@raspberrypi:~/proxychains-ng-master $ proxychains4 curl ip.sb</span><br><span class="line">[proxychains] config file found: /etc/proxychains.conf</span><br><span class="line">[proxychains] preloading /usr/<span class="built_in">local</span>/lib/libproxychains4.so</span><br><span class="line">[proxychains] DLL init: proxychains-ng 4.14</span><br><span class="line">[proxychains] Strict chain  ...  127.0.0.1:1080  ...  ip.sb:80  ...  OK</span><br><span class="line">34.92.xxx.xxx</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git用起来太慢了, 几乎不能用 , ss又经常被封端口, 并不是很稳, 使用最近很流行的v2ray试试&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="http://blog.ichenfei.com/2019/11/24/hello-world/"/>
    <id>http://blog.ichenfei.com/2019/11/24/hello-world/</id>
    <published>2019-11-23T18:00:12.045Z</published>
    <updated>2019-11-23T19:54:14.768Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>树莓派实现温控风扇</title>
    <link href="http://blog.ichenfei.com/2019/11/23/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E6%B8%A9%E6%8E%A7%E9%A3%8E%E6%89%87/"/>
    <id>http://blog.ichenfei.com/2019/11/23/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E6%B8%A9%E6%8E%A7%E9%A3%8E%E6%89%87/</id>
    <published>2019-11-23T15:17:54.000Z</published>
    <updated>2019-11-23T15:21:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>树莓派风扇声音太大了, 非常影响睡觉， 不开风扇cpu温度又很容易太高了</p><a id="more"></a><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>杜邦线母对母2根, 公对母2根, 直接淘宝买40pin的2排</li><li>三极管S85501个，淘宝买2块钱50个包邮<ul><li>S8550为PNP型三极管，基极施加低电平时才导通电路，如果是用的NPN型三极管则与之相反</li></ul></li><li>树莓派小风扇1个</li></ul><p>树莓派引脚:</p><p><img src="https://www.ichenfei.com/wp-content/uploads/2019/11/94a0bbf61ddf391db56f1cc23bfd7ef3.png" alt></p><p>三极管引脚:</p><p><img src="https://www.ichenfei.com/wp-content/uploads/2019/11/82c6e79943b3e1afd4b2fa97620df019.png" alt></p><ul><li>E: 发射机 <ul><li>正级(接电源正极, 5V)</li><li>可接树莓派4号引脚</li></ul></li><li>B: 基级 <ul><li>信号极控制是否通电(GPIO)</li><li>可以接树莓派8号引脚</li></ul></li><li>C：集电极<ul><li>负极 (接电源负极, Ground)</li><li>可以接树莓派6号引脚</li></ul></li></ul><h2 id="接线"><a href="#接线" class="headerlink" title="接线"></a>接线</h2><ol><li>风扇红线(正极)接树莓派5V，如4号引脚</li><li>风扇黑线(负极)接三极管C(集电集)</li><li>三极管E(发射极)接树莓派Ground, 如6号引脚</li><li>三极管B级, 接树莓派GPIO，如8号引脚</li></ol><p>如图: <img src="https://www.ichenfei.com/wp-content/uploads/2019/11/d2be99357e792fc7968637f9e2d98af7.png" alt></p><h2 id="Python程序风扇"><a href="#Python程序风扇" class="headerlink" title="Python程序风扇"></a>Python程序风扇</h2><p>在python交互式命令行下测试下是否可行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~/script $ python</span><br><span class="line">Python 2.7.16 (default, Apr  6 2019, 01:42:57) </span><br><span class="line">[GCC 8.2.0] on linux2</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; import RPi.GPIO as GPIO</span><br><span class="line">&gt;&gt;&gt; GPIO_OUT = 14</span><br><span class="line">&gt;&gt;&gt; GPIO.setmode(GPIO.BCM)</span><br><span class="line">&gt;&gt;&gt; GPIO.setwarnings(False)</span><br><span class="line">&gt;&gt;&gt; GPIO.setup(GPIO_OUT, GPIO.OUT, initial=GPIO.HIGH)</span><br><span class="line">&gt;&gt;&gt; GPIO.output(GPIO_OUT, GPIO.LOW)  # 风扇开</span><br><span class="line">&gt;&gt;&gt; GPIO.output(GPIO_OUT, GPIO.HIGH) # 风扇关闭</span><br><span class="line"></span><br><span class="line">注：PNP型三极管GPIO.LOW是开, HIGH是关， NPN型相反</span><br></pre></td></tr></table></figure></p><h2 id="完整程序"><a href="#完整程序" class="headerlink" title="完整程序:"></a>完整程序:</h2><p><a href="https://raw.githubusercontent.com/lovehhf/raspi_script/master/smartfan.py" target="_blank" rel="noopener">smartfan.py</a></p><p>主要逻辑:</p><ol><li>读取<code>/sys/class/thermal/thermal_zone0/temp</code>内容, 除1000获取CPU温度</li><li>风扇初始状态设置为关闭状态</li><li>温度低于55度且当前处于关闭状态开机风扇</li><li>温度低于45度且当前处于开启状态关闭风扇</li><li>每隔15秒查一下温度并更新状态</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /home/pi/script &amp;&amp; cd /home/pi/script</span><br><span class="line">wget https://raw.githubusercontent.com/lovehhf/raspi_script/master/smartfan.py</span><br></pre></td></tr></table></figure><h2 id="supervisor管理python进程"><a href="#supervisor管理python进程" class="headerlink" title="supervisor管理python进程"></a>supervisor管理python进程</h2><p>添加配置文件: <code>vim /etc/supervisor/conf.d/fan.conf</code>:<br>内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[program:fan]</span><br><span class="line">command=/usr/bin/python3 /home/pi/script/smartfan.py</span><br><span class="line">user=root</span><br><span class="line">directory=/home/pi/script</span><br><span class="line">stdout_logfile=/var/log/supervisor/%(program_name)s-stdout.log</span><br><span class="line">stderr_logfile=/var/log/supervisor/%(program_name)s-stderr.log</span><br><span class="line">autorestart=true</span><br><span class="line">autostart=true</span><br></pre></td></tr></table></figure></p><p>重启supervisor并查看状态:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:/var/log $ sudo systemctl restart supervisor</span><br><span class="line">pi@raspberrypi:/var/log $ sudo supervisorctl status fan</span><br><span class="line">fan                              RUNNING   pid 3903, uptime 0:01:26</span><br></pre></td></tr></table></figure></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install stress</span><br><span class="line">stress -c 50   # cpu压力测试, 开50个进程不停地sqrt, 一下子风扇就转起来了</span><br><span class="line">tail -f /var/log/fan_control.log  # 查看日志</span><br></pre></td></tr></table></figure><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h4><ul><li><a href="https://segmentfault.com/a/1190000017225701" target="_blank" rel="noopener">三极管打造树莓派温控风扇</a></li><li><a href="https://blog.newnius.com/raspberry-control-fan-with-transistor.html" target="_blank" rel="noopener">树莓派—利用三极管控制散热风扇</a></li><li><a href="https://www.jianshu.com/p/20fea50cf483" target="_blank" rel="noopener">用Python做一个温控风扇-树莓派</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树莓派风扇声音太大了, 非常影响睡觉， 不开风扇cpu温度又很容易太高了&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title> 二叉树的前中后序遍历的非递归实现(Python)		</title>
    <link href="http://blog.ichenfei.com/2019/05/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0(Python)/"/>
    <id>http://blog.ichenfei.com/2019/05/02/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0(Python)/</id>
    <published>2019-05-01T16:19:58.000Z</published>
    <updated>2019-11-23T18:37:04.524Z</updated>
    
    <content type="html"><![CDATA[<p>二叉树的前中后序遍历的非递归实现</p><a id="more"></a><h2 id="二叉树定义"><a href="#二叉树定义" class="headerlink" title="二叉树定义"></a>二叉树定义</h2><pre><code>class TreeNode:    def __init__(self, x, L=None, R=None):        self.val = x        self.left = L        self.right = Rdef List2TN(lst, needs=None):    &apos;&apos;&apos;    lst: a leetcode way tree list    needs: A list of Int. The nodes whose indexes provided in this list would be returned.    &apos;&apos;&apos;    nit = []    root = TreeNode(lst[0])    tnQ = [root]    i = 1    if needs and i in needs:        nit.append(root)    while i &lt; len(lst):        cur = tnQ.pop(0)        if lst[i] != None:            cur.left = TreeNode(lst[i])            tnQ.append(cur.left)            if needs and i in needs:                nit.append(cur.left)        i += 1        if i &gt;= len(lst):            break        if lst[i] != None:            cur.right = TreeNode(lst[i])            tnQ.append(cur.right)            if needs and i in needs:                nit.append(cur.right)        i += 1    if needs:        return root, nit    else:        return root</code></pre><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><ul><li><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/submissions/" target="_blank" rel="noopener">144. 二叉树的前序遍历</a></li></ul><h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><p>1、首先申请一个新的栈，记为stack。 2、然后将头节点head压入stack中。 3、每次从stack中弹出栈顶节点，记为cur，然后打印cur节点的值。如果cur右孩子不为空的话，将cur的右孩子先压入stack中。最后如果cur的左孩子不为空的话，将cur的左孩子压入stack中。 4、不断重复步骤3，直到stack为空，全部过程结束。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>class Solution(object):    def preorderTraversal(self,root):        &quot;&quot;&quot;        根-&gt;左-&gt;右        :type root: TreeNode        :rtype: List[int]        &quot;&quot;&quot;        stack = [root]        res = []        while stack:            cur = stack.pop()            res.append(cur.val)            if cur.right:                stack.append(cur.right)            if cur.left:                stack.append(cur.left)        return res</code></pre><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><ul><li><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94. 二叉树的中序遍历</a></li></ul><h4 id="具体过程-1"><a href="#具体过程-1" class="headerlink" title="具体过程"></a>具体过程</h4><ul><li>1、申请一个新的栈，记为<code>stack</code>，申请一个变量<code>cur</code>，初始时令<code>stack</code>为空,<code>cur</code>等于头节点。</li><li>2、先把<code>cur</code>节点压入栈中，对以cur节点为头的整棵子树来说，依次把整棵树的左边界压入栈中，即不断令<code>cur=cur.left</code>，然后重复步骤2。</li><li>3、不断重复步骤2，直到发现<code>cur</code>为空，此时从<code>stack</code>中弹出一个节点，记为<code>node</code>。打印<code>node</code>的值，并让<code>cur=node.right</code>，然后继续重复步骤2。</li><li>4、当<code>stack</code>为空并且<code>cur</code>为空时，整个过程结束。</li></ul><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>class Solution(object):    def inorderTraversal(self, root):        &quot;&quot;&quot;        左-&gt;根-&gt;右        :type root: TreeNode        :rtype: List[int]        &quot;&quot;&quot;        stack = []        cur = root        res = []        while stack or cur:            if cur:                stack.append(cur)                cur = cur.left            else:                node = stack.pop()                res.append(node.val)                cur = node.right        return res</code></pre><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145. 二叉树的后序遍历</a></li></ul><h4 id="具体过程-2"><a href="#具体过程-2" class="headerlink" title="具体过程"></a>具体过程</h4><p><strong>方法一：使用两个栈实现</strong> 1、申请一个栈，记为s1，然后将头节点压入s1中。 2、从s1中弹出的节点记为cur，然后先把cur的左孩子压入s1中，然后把cur的右孩子压入s1中。 3、在整个过程中，每一个从s1中弹出的节点都放进第二个栈s2中。 4、不断重复步骤2和步骤3，直到s1为空，过程停止。 5、从s2中依次弹出节点并打印，打印的顺序就是后序遍历的顺序了。 <strong>方法二：使用一个栈实现</strong> 1、申请一个栈，记为stack，将头节点压入stack，同时设置两个变量h和c。在整个流程中，h代表最近一次弹出并打印的节点，c代表当前stack的栈顶节点，初始时令h为头节点，c为null。 2、每次令c等于当前stack的栈顶节点，但是不从stack中弹出节点，此时分以下三种情况。 （1）如果c的左孩子不为空，并且h不等于c的左孩子，也不等于c的右孩子，则把c的左孩子压入stack中。 （2）如果情况1不成立，并且c的右孩子不为空，并且h不等于c的右孩子，则把c的右孩子压入stack中。 （3）如果情况1和情况2都不成立，那么从stack中弹出c并打印，然后令h等于c。 3、一直重复步骤2，直到stack为空，过程停止。</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><p>方法一:</p><pre><code>class Solution(object):    def postorderTraversal(self, root):        &quot;&quot;&quot;        左-&gt;右-&gt;根        :type root: TreeNode        :rtype: List[int]        &quot;&quot;&quot;        stack1 = [root]        stack2 = []        while stack1:            cur = stack1.pop()            stack2.append(cur.val)            if cur.left:                stack1.append(cur.left)            if cur.right:                stack1.append(cur.right)        return stack2[::-1]</code></pre><h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><h4 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h4><pre><code>def bfs(root):    queue = []    # 根节点加入队列中    queue.append(root)    res = []    while queue:        temp = queue.pop(0)        l = temp.left        r = temp.right        if l:            queue.append(l)        if r:            queue.append(r)        res.append(temp.val)    return res</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二叉树的前中后序遍历的非递归实现&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.ichenfei.com/categories/Python/"/>
    
      <category term="算法学习" scheme="http://blog.ichenfei.com/categories/Python/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="二叉树" scheme="http://blog.ichenfei.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="数据结构" scheme="http://blog.ichenfei.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title> Python的列表乘法问题		</title>
    <link href="http://blog.ichenfei.com/2019/04/28/Python%E7%9A%84%E5%88%97%E8%A1%A8%E4%B9%98%E6%B3%95%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.ichenfei.com/2019/04/28/Python%E7%9A%84%E5%88%97%E8%A1%A8%E4%B9%98%E6%B3%95%E9%97%AE%E9%A2%98/</id>
    <published>2019-04-28T06:41:58.000Z</published>
    <updated>2019-11-23T18:21:10.175Z</updated>
    
    <content type="html"><![CDATA[<p>分清楚是传的是值还是引用</p><a id="more"></a><p>Python在对列表的初始化过程中会经常用到列表的乘法生成一个含有重复元素的列表,例如 <code>l = [0]*10</code> 但是如果列表中包含有可变数据类型(列表、字典)的话使用<code>*</code>操作符便会有很大问题。 <code>*</code>操作符在实现上是复制了值的引用，而不是创建了新的对象。如果其中一个数据改变，其他的也会跟着改变。 如下代码:</p><pre><code>m = 2n = 3dp = [[0 for _ in range(n+1)] for _ in range(m+1)]dp2 = [[0] * (n + 1)] * (m + 1)dp2[1][1] = 1dp[1][1] = 1print(dp)print(dp2)</code></pre><p>在<code>pythontutor</code>中可视化代码运行过程，可以看出使用dp2中的使用<code>*</code>操作符生成的列表中的3个元素都指向的同一个<code>list</code>。而使用列表生成式生成的二维列表指向的都是不同的<code>list</code>。 故python在初始化列表中尽量要使用列表生成器，而尽量少使用列表乘法。 <img src="https://www.ichenfei.com/wp-content/uploads/2019/04/f8670646faaf32805ee52d158a5a7242.png" alt> 参考链接: - <a href="https://blog.csdn.net/wangxinginnlp/article/details/53201450" target="_blank" rel="noopener">小心python的list乘法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分清楚是传的是值还是引用&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.ichenfei.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title> Python zip函数使用技巧		</title>
    <link href="http://blog.ichenfei.com/2019/03/29/Python%20zip%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://blog.ichenfei.com/2019/03/29/Python%20zip%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2019-03-29T14:22:25.000Z</published>
    <updated>2019-11-23T18:27:10.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>zip() 函数用于将可迭代对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象。 如果各个可迭代对象的元素个数不一致，则返回的对象长度与最短的可迭代对象相同。 利用 <em> 号操作符，与zip相反，进行解压。 zip(a,b…): 将多个列表压缩为一个二维列表 zip(</em>a): 将一个二维列表解压为多个列表</p><a id="more"></a><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code>语法:zip(iter1 [,iter2 [...]])参数:iter1:一个或多个可迭代对象（字符串、列表、元祖、字典）返回值:--&gt; zip object</code></pre><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例:"></a>使用示例:</h2><p><img src="https://www.ichenfei.com/wp-content/uploads/2019/03/03d295c17556dbd50160ff8f321c8780.png" alt></p><h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><h2 id="1、将两个列表合并为字典"><a href="#1、将两个列表合并为字典" class="headerlink" title="1、将两个列表合并为字典"></a>1、将两个列表合并为字典</h2><pre><code>a = [chr(ord(&apos;a&apos;)+i) for i in range(0,10)]b = list(range(0,26))print(a)print(b)print(dict(zip(a,b)))[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;][0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]{&apos;a&apos;: 0, &apos;b&apos;: 1, &apos;c&apos;: 2, &apos;d&apos;: 3, &apos;e&apos;: 4, &apos;f&apos;: 5, &apos;g&apos;: 6, &apos;h&apos;: 7, &apos;i&apos;: 8, &apos;j&apos;: 9}</code></pre><h2 id="2、-旋转矩阵"><a href="#2、-旋转矩阵" class="headerlink" title="2、 旋转矩阵"></a>2、 旋转矩阵</h2><h3 id="示例1-顺时针旋转"><a href="#示例1-顺时针旋转" class="headerlink" title="示例1 顺时针旋转:"></a>示例1 顺时针旋转:</h3><p><a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener">LeetCode 48. 旋转图像</a></p><blockquote><p>给定一个 <code>n × n</code> 的二维矩阵表示一个图像。将图像顺时针旋转 <code>90</code> 度。</p></blockquote><p>说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p><pre><code>示例 1:给定matrix = [  [1,2,3],  [4,5,6],  [7,8,9]],原地旋转输入矩阵，使其变为:[  [7,4,1],  [8,5,2],  [9,6,3]]</code></pre><p>思路:</p><pre><code>先zip(*)解压为,再对每行翻转[[1,2,3],[4,5,6],[7,8,9]] -&gt; [[1,4,7],[2,5,8],[3,6,9]] -&gt; [[7,4,1],[8,5,2],[9,6,3]]或者:[[1,2,3],[4,5,6],[7,8,9]] -&gt; [[7,8,9],[4,5,6],[1,2,3]] -&gt; [[7,4,1],[8,5,2],[9,6,3]]</code></pre><p>代码:</p><pre><code>def rotate(matrix):    matrix[:] = list(zip(*matrix[::-1]))def rotate2(matrix):    matrix[:] = [x[::-1] for x in list(zip(*matrix))]A = [  [1,2,3],  [4,5,6],  [7,8,9]]rotate(A)print(A)[(7, 4, 1), (8, 5, 2), (9, 6, 3)]</code></pre><h3 id="示例2-逆时针旋转"><a href="#示例2-逆时针旋转" class="headerlink" title="示例2 逆时针旋转:"></a>示例2 逆时针旋转:</h3><p><a href="https://leetcode-cn.com/problems/spiral-matrix/" target="_blank" rel="noopener">LeetCode 54. 螺旋矩阵</a></p><blockquote><p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p></blockquote><pre><code>示例 1:输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,3,6,9,8,7,4,5]</code></pre><p>代码:</p><pre><code>def spiralOrder(matrix):    &quot;&quot;&quot;    :param matrix: 二维列表    :return: 顺时针输出的一维数组    &quot;&quot;&quot;    res = []    while matrix:        &quot;&quot;&quot;        删除第一行 然后二维数组逆时针旋转90度 继续再删除第一行 一直这样直到没有可以输出的了        [          [5, 6, 7, 8],   ===&gt;   [[8,12],[7,11],[6,10],[5,9]]          [9,10,11,12]        ]        &quot;&quot;&quot;        res += matrix.pop(0)        if matrix:            matrix[:] = zip(*list(map(reversed,matrix)))    return resprint(spiralOrder([  [1, 2, 3, 4],  [5, 6, 7, 8],  [9,10,11,12]]))[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;zip() 函数用于将可迭代对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象。 如果各个可迭代对象的元素个数不一致，则返回的对象长度与最短的可迭代对象相同。 利用 &lt;em&gt; 号操作符，与zip相反，进行解压。 zip(a,b…): 将多个列表压缩为一个二维列表 zip(&lt;/em&gt;a): 将一个二维列表解压为多个列表&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.ichenfei.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Jupyter Notebook使用记录		</title>
    <link href="http://blog.ichenfei.com/2019/03/15/Jupyter%20Notebook%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <id>http://blog.ichenfei.com/2019/03/15/Jupyter%20Notebook%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</id>
    <published>2019-03-15T05:11:13.000Z</published>
    <updated>2019-11-24T07:02:56.219Z</updated>
    
    <content type="html"><![CDATA[<p>Jupyter Notebook是基于网页的用于交互计算的应用程序。其可被应用于全过程计算：开发、文档编写、运行代码和展示结果。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyterlab</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jupyter --<span class="built_in">help</span></span><br><span class="line">jupyter notebook --<span class="built_in">help</span></span><br><span class="line">jupyter notebook --<span class="built_in">help</span>-all</span><br><span class="line">jupyter notebook --generate-config  生成配置文件</span><br><span class="line">jupyter notebook --port  指定端口,默认888</span><br><span class="line">jupyter notebook --ip    指定ip,默认localhost</span><br><span class="line">jupyter notebook --no-browser  启动时不打开浏览器</span><br><span class="line">jupyter notebook password 设置密码</span><br><span class="line"></span><br><span class="line">jupyter kernelspec list  查看内核</span><br><span class="line">jupyter kernelspec remove &#123;name&#125;  删除内核</span><br></pre></td></tr></table></figure><p>示例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --no-browser --ip 0.0.0.0 --port 8080</span><br></pre></td></tr></table></figure></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>设置访问密码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; jupyter notebook password</span><br><span class="line"></span><br><span class="line">Enter password:</span><br><span class="line">Verify password:</span><br><span class="line">[NotebookPasswordApp] Wrote hashed password to C:\Users\xxx\.jupyter\jupyter_notebook_config.json</span><br></pre></td></tr></table></figure><p>添加内核:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">workon py36_env</span><br><span class="line">pip install ipykernel</span><br><span class="line">python -m ipykernel install --name <span class="string">"py36env"</span></span><br></pre></td></tr></table></figure></p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><table><thead><tr><th>模式</th><th>组合键</th><th>说明</th></tr></thead><tbody><tr><td>编辑模式</td><td>Esc</td><td>切换到命令模式</td></tr><tr><td>命令模式</td><td>A</td><td>在当前Cell上方新建Cell</td></tr><tr><td>命令模式</td><td>B</td><td>在当前Cell下方新建Cell</td></tr><tr><td>命令模式</td><td>DD</td><td>删除当前单元</td></tr><tr><td>命令模式</td><td>Y</td><td>切换到Code状态</td></tr><tr><td>命令模式</td><td>M</td><td>切换到Markdown状态</td></tr><tr><td>命令模式</td><td>II</td><td>中断内核运行</td></tr><tr><td>命令模式</td><td>L</td><td>显示代码框中每行的数字标识</td></tr><tr><td>命令模式</td><td>shift + v</td><td>粘贴单元格</td></tr><tr><td>命令模式</td><td>shift + L</td><td>显示全部代码框中每行的数字标识</td></tr><tr><td>编辑模式</td><td>shift + Tab</td><td>查看当前函数的说明（光标要在函数的位置内）</td></tr><tr><td>命令/编辑模式</td><td>shift + enter</td><td>运行当前单元后,进入下一单元</td></tr><tr><td>命令/编辑模式</td><td>ctrl + enter</td><td>只运行当前单元,不进入下一单元</td></tr></tbody></table><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul><li><a href="https://jupyter.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">Jupyter Documentation</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jupyter Notebook是基于网页的用于交互计算的应用程序。其可被应用于全过程计算：开发、文档编写、运行代码和展示结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.ichenfei.com/categories/Python/"/>
    
      <category term="tools" scheme="http://blog.ichenfei.com/categories/Python/tools/"/>
    
    
  </entry>
  
  <entry>
    <title> Windows安装Burpsuite过程记录		</title>
    <link href="http://blog.ichenfei.com/2018/11/11/Windows%E5%AE%89%E8%A3%85Burpsuite%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <id>http://blog.ichenfei.com/2018/11/11/Windows%E5%AE%89%E8%A3%85Burpsuite%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</id>
    <published>2018-11-11T03:15:36.000Z</published>
    <updated>2019-11-23T18:37:35.167Z</updated>
    
    <content type="html"><![CDATA[<p>Windows安装Burpsuite</p><a id="more"></a><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><h2 id="1、官网下载并安装社区版"><a href="#1、官网下载并安装社区版" class="headerlink" title="1、官网下载并安装社区版"></a>1、官网下载并安装社区版</h2><pre><code>https://portswigger.net/burp/communitydownload </code></pre><h2 id="2、吾爱破解下载keygen"><a href="#2、吾爱破解下载keygen" class="headerlink" title="2、吾爱破解下载keygen"></a>2、吾爱破解下载keygen</h2><pre><code>https://down.52pojie.cn/Tools/Network_Analyzer/Burp_Suite_Pro_v1.7.37_Loader_Keygen.zip</code></pre><p>到BurpSuite安装目录下,目录下有个<code>burpsuite_community.jar</code>,备份为<code>burpsuite_community.jar.bak</code> 把解压得到的<code>burpsuite_pro_v1.7.37.jar</code>复制到此文件夹并重命名为<code>burpsuite_community.jar</code> <img src="https://www.ichenfei.com/wp-content/uploads/2019/03/be6c7fe93fa087c30a5482c4876e95d3.png" alt> 把解压得到的<code>burp-loader-keygen.jar</code>复制到此文件夹</p><h2 id="破解过程"><a href="#破解过程" class="headerlink" title="破解过程"></a>破解过程</h2><p>打开burp,顺利的话会出现输入license key的界面 双击打开burp-loader-keygen.jar,复制粘贴,点next 点<code>manual activation</code> 复制burp中的request到<code>activation request</code>,自动生成response,粘贴到burp的response中,点next 出现成功界面</p><h2 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h2><p>burpsuite.bat</p><pre><code>@echo offjava -Xbootclasspath/p:burp-loader-keygen.jar -jar burpsuite_community.jarexit</code></pre><p>点击启动的时候会有个cmd小窗口,很烦 添加个vbs脚本,去掉cmd窗口的弹框 <code>burpsuite.vbs:</code></p><pre><code>set ws=wscript.createobject(&quot;wscript.shell&quot;)ws.run &quot;burpsuite.bat /start&quot;,0</code></pre><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h4><ul><li><a href="https://www.52pojie.cn/thread-691448-1-1.html" target="_blank" rel="noopener">Burp Suite Pro Loader&amp;Keygen By surferxyz（更新新版，附带v1.7.37原版）</a></li><li><a href="https://blog.csdn.net/hometown5/article/details/79532347" target="_blank" rel="noopener">Burp Suite v1.7.32破解升级pro</a></li><li><a href="http://ximcx.cn/post-110.html" target="_blank" rel="noopener">Burp Suite Pro2.0.07破解版-2018.10.04更新</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Windows安装Burpsuite&lt;/p&gt;
    
    </summary>
    
    
      <category term="tools" scheme="http://blog.ichenfei.com/categories/tools/"/>
    
    
      <category term="Burpsuite" scheme="http://blog.ichenfei.com/tags/Burpsuite/"/>
    
      <category term="抓包工具" scheme="http://blog.ichenfei.com/tags/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title> Sublime Text写markdown粘贴图片问题		</title>
    <link href="http://blog.ichenfei.com/2018/08/08/Sublime%20Text%E5%86%99markdown%E7%B2%98%E8%B4%B4%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.ichenfei.com/2018/08/08/Sublime%20Text%E5%86%99markdown%E7%B2%98%E8%B4%B4%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/</id>
    <published>2018-08-08T09:09:14.000Z</published>
    <updated>2019-11-24T07:06:51.830Z</updated>
    
    <content type="html"><![CDATA[<p>Sublime Text写markdown粘贴图片问题</p><a id="more"></a><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在<code>sulime text</code>里面书写<code>markdown</code>的时候,碰到需要粘贴图片的问题，图片和文本不是一种格式，因此不能直接粘贴,每次图片都需要手动保存文件</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>安装<code>ImagePaste</code>插件,按下ctrl+v的时候，把自动把图片保存的你写的md文件的同级目录，并且会创建一个和md文件同名的文件夹 在md文件类型里面按下ctrl+v的时候，自动生成链接标签。如下：</p><h2 id="sublime-使用-markdown-相关"><a href="#sublime-使用-markdown-相关" class="headerlink" title="sublime 使用 markdown 相关"></a>sublime 使用 markdown 相关</h2><p>插件<code>OmniMarkupPreviewer</code>快捷键</p><ul><li>Ctrl+Alt+O: 在浏览器中预览markdown</li><li>Ctrl+Alt+X: 保存为HTML</li><li>Ctrl+Alt+C: 将Markdown复制HTML源码到剪贴板上</li></ul><p><a href="https://packagecontrol.io/packages/OmniMarkupPreviewer" target="_blank" rel="noopener">OmniMarkupPreviewer-packages地址</a> <a href="https://github.com/timonwong/OmniMarkupPreviewer" target="_blank" rel="noopener">OmniMarkupPreviewer-Github地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Sublime Text写markdown粘贴图片问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="markdown" scheme="http://blog.ichenfei.com/categories/markdown/"/>
    
    
      <category term="ImagePaste" scheme="http://blog.ichenfei.com/tags/ImagePaste/"/>
    
      <category term="markdown" scheme="http://blog.ichenfei.com/tags/markdown/"/>
    
      <category term="OmniMarkupPreviewer" scheme="http://blog.ichenfei.com/tags/OmniMarkupPreviewer/"/>
    
      <category term="sublime text" scheme="http://blog.ichenfei.com/tags/sublime-text/"/>
    
  </entry>
  
  <entry>
    <title> 解决supervisor无法启动es的问题		</title>
    <link href="http://blog.ichenfei.com/2018/08/07/%E8%A7%A3%E5%86%B3supervisor%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8es%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.ichenfei.com/2018/08/07/%E8%A7%A3%E5%86%B3supervisor%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8es%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2018-08-07T08:55:20.000Z</published>
    <updated>2019-11-23T18:37:21.664Z</updated>
    
    <content type="html"><![CDATA[<p>解决supervisor无法启动es的问题<br><a id="more"></a></p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>虚拟机<code>ubuntu18.04 es6.3.0</code> 修改<code>network.host: 0.0.0.0</code>后终端能正常启动es,而<code>supervisor</code>却启动失败 报错如下</p><pre><code>[2018-08-07T16:42:03,539][INFO ][o.e.d.DiscoveryModule    ] [jx0BXwT] using discovery type [zen][2018-08-07T16:42:05,009][INFO ][o.e.n.Node               ] [jx0BXwT] initialized[2018-08-07T16:42:05,010][INFO ][o.e.n.Node               ] [jx0BXwT] starting ...[2018-08-07T16:42:05,247][INFO ][o.e.t.TransportService   ] [jx0BXwT] publish_address {192.168.163.134:9300}, bound_addresses {[::]:9300}[2018-08-07T16:42:05,297][INFO ][o.e.b.BootstrapChecks    ] [jx0BXwT] bound or publishing to a non-loopback address, enforcing bootstrap checksERROR: [1] bootstrap checks failed[1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536][2018-08-07T16:42:05,322][INFO ][o.e.n.Node               ] [jx0BXwT] stopping ...[2018-08-07T16:42:05,371][INFO ][o.e.n.Node               ] [jx0BXwT] stopped[2018-08-07T16:42:05,372][INFO ][o.e.n.Node               ] [jx0BXwT] closing ...[2018-08-07T16:42:05,385][INFO ][o.e.n.Node               ] [jx0BXwT] closed[2018-08-07T16:42:05,388][INFO ][o.e.x.m.j.p.NativeController] Native controller process has stopped - no new native processes can be started</code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><pre><code>sudo vim /etc/supervisor/supervisord.conf </code></pre><p><code>[supervisord]</code>中添加</p><pre><code>minfds=65536minprocs=32768</code></pre><p><img src="https://www.ichenfei.com/wp-content/uploads/2018/08/d12224319113724d419eb55ec6b1824c.png" alt> 重启 <code>supervisor</code> 服务可解决</p><pre><code>sudo service supervisor restart</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.tech1024.cn/original/2962.html" target="_blank" rel="noopener">Elasticsearch在Centos 7上的安装与配置</a></li><li><a href="https://blog.csdn.net/sinat_21302587/article/details/77645676" target="_blank" rel="noopener">supervisord 启动elasticsearch 失败</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解决supervisor无法启动es的问题&lt;br&gt;
    
    </summary>
    
    
      <category term="elasticsearch" scheme="http://blog.ichenfei.com/categories/elasticsearch/"/>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu 终端使用shadowsocks全局代理		</title>
    <link href="http://blog.ichenfei.com/2017/11/16/Ubuntu%20%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8shadowsocks%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86/"/>
    <id>http://blog.ichenfei.com/2017/11/16/Ubuntu%20%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8shadowsocks%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86/</id>
    <published>2017-11-16T02:29:24.000Z</published>
    <updated>2019-11-24T06:56:20.958Z</updated>
    
    <content type="html"><![CDATA[<p>Ubuntu 终端使用shadowsocks全局代理</p><a id="more"></a><h2 id="配置-ShadowSocks-客户端"><a href="#配置-ShadowSocks-客户端" class="headerlink" title="配置 ShadowSocks 客户端"></a>配置 ShadowSocks 客户端</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-pip</span><br><span class="line">sudo pip install shadowsocks</span><br><span class="line">sudo vim /etc/ssclient.conf</span><br></pre></td></tr></table></figure><p>配置文件如下:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"serverip"</span>,</span><br><span class="line">    <span class="attr">"server_port"</span>:<span class="number">12345</span>,</span><br><span class="line">    <span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"ss密码"</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line">    <span class="attr">"fast_open"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"workers"</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置说明:</p><ul><li>“server”<ul><li>服务端ip</li></ul></li><li>“method”<ul><li>加密方式</li></ul></li><li>“password”<ul><li>服务端密码</li></ul></li><li>“fast_open”<ul><li>可选 true 或 false。如果你的服务器 Linux 内核在3.7+，可以开启 fast_open 以降低延迟。开启方法： echo 3 &gt; /proc/sys/net/ipv4/tcp_fastopen 开启之后，将 fast_open 的配置设置为 true 即可</li></ul></li></ul><p>开启shadowsocks:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tmux</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 SS</span></span><br><span class="line">sudo nohup sslocal -c /etc/ssclient.conf &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="comment"># 查看进程</span></span><br><span class="line">sudo ps aux |grep sslocal |grep -v <span class="string">"grep"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加开启启动</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"nohup /usr/local/bin/sslocal -c /etc/ssclient.conf /dev/null 2&gt;&amp;1 &amp;"</span> &gt;&gt; /etc/rc.local</span><br></pre></td></tr></table></figure><p>如果启动<code>sslocal</code>出现错误:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AttributeError: /usr/lib/x86_64-linux-gnu/libcrypto.so.1.1: undefined symbol: EVP_CIPHER_CTX_cleanup</span><br></pre></td></tr></table></figure></p><p>参考解决方法: <a href="https://github.com/shadowsocks/shadowsocks/issues/646#issuecomment-267977330" target="_blank" rel="noopener">run sslocal raise error</a>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -U git+https://github.com/shadowsocks/shadowsocks.git@master</span><br></pre></td></tr></table></figure><h2 id="使用-privoxy-将Sock5代理转化为Http代理"><a href="#使用-privoxy-将Sock5代理转化为Http代理" class="headerlink" title="使用 privoxy 将Sock5代理转化为Http代理"></a>使用 privoxy 将Sock5代理转化为Http代理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install privoxy -y</span><br></pre></td></tr></table></figure><p>修改配置文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/privoxy/config /etc/privoxy/config.bak     <span class="comment"># 备份配置文件</span></span><br><span class="line">sed -i <span class="string">'/^#/d'</span> /etc/privoxy/config                      <span class="comment"># 删除#开头的注释行(太多了,看着累)</span></span><br><span class="line">sudo vim /etc/privoxy/config                            <span class="comment"># 修改配置文件</span></span><br></pre></td></tr></table></figure><p>找到 <code>listen-address</code> 确保有这行代码 <code>listen-address 127.0.0.1:8118</code><br>找到 <code>forward-socks5</code> 确保有这行代码(没有自己加) <code>forward-socks5 / 127.0.0.1:1080 .</code></p><p>配置文件如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">user-manual /usr/share/doc/privoxy/user-manual</span><br><span class="line">confdir /etc/privoxy</span><br><span class="line">logdir /var/log/privoxy</span><br><span class="line">actionsfile match-all.action # Actions that are applied to all sites and maybe overruled later on.</span><br><span class="line">actionsfile default.action   # Main actions file</span><br><span class="line">actionsfile user.action      # User customizations</span><br><span class="line">filterfile default.filter</span><br><span class="line">filterfile user.filter      # User customizations</span><br><span class="line">logfile logfile</span><br><span class="line">listen-address  127.0.0.1:8118</span><br><span class="line">listen-address  [::1]:8118</span><br><span class="line">toggle  1</span><br><span class="line">enable-remote-toggle  0</span><br><span class="line">enable-remote-http-toggle  0</span><br><span class="line">enable-edit-actions 0</span><br><span class="line">enforce-blocks 0</span><br><span class="line">buffer-limit 4096</span><br><span class="line">enable-proxy-authentication-forwarding 0</span><br><span class="line">forwarded-connect-retries  0</span><br><span class="line">accept-intercepted-requests 0</span><br><span class="line">allow-cgi-request-crunching 0</span><br><span class="line">split-large-forms 0</span><br><span class="line">keep-alive-timeout 5</span><br><span class="line">tolerate-pipelining 1</span><br><span class="line">socket-timeout 300</span><br><span class="line">forward-socks5 / 127.0.0.1:1080 .</span><br></pre></td></tr></table></figure></p><p>启动<code>privoxy</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo service privoxy start</span><br><span class="line">sudo service privoxy status</span><br></pre></td></tr></table></figure><p>配置转发</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">"http://127.0.0.1:8118"</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">"http://127.0.0.1:8118"</span></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~<span class="comment"># curl 4.icanhazip.com</span></span><br><span class="line">35.201.129.180</span><br></pre></td></tr></table></figure><h2 id="也可以使用-Polipo-代替-Privoxy"><a href="#也可以使用-Polipo-代替-Privoxy" class="headerlink" title="也可以使用 Polipo 代替 Privoxy"></a>也可以使用 Polipo 代替 Privoxy</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install polipo -y</span><br><span class="line"></span><br><span class="line">cp /etc/polipo/config /etc/polipo/config.bak</span><br><span class="line"></span><br><span class="line">cat &gt; /etc/polipo/config&lt;&lt;EOF</span><br><span class="line">logSyslog = <span class="literal">true</span></span><br><span class="line">logFile = /var/<span class="built_in">log</span>/polipo/polipo.log</span><br><span class="line">proxyAddress = <span class="string">"0.0.0.0"</span></span><br><span class="line">socksParentProxy = <span class="string">"127.0.0.1:1080"</span></span><br><span class="line">socksProxyType = socks5</span><br><span class="line">chunkHighMark = 50331648</span><br><span class="line">objectHighMark = 16384</span><br><span class="line">serverMaxSlots = 64</span><br><span class="line">serverSlots = 16</span><br><span class="line">serverSlots1 = 32</span><br><span class="line">EOF</span><br><span class="line">sudo /etc/init.d/polipo restart</span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">"http://127.0.0.1:8123/"</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">"http://127.0.0.1:8123/"</span></span><br></pre></td></tr></table></figure><p><img src="https://www.ichenfei.com/wp-content/uploads/2017/11/2449c06687ad793c5b742df6dcfc6b70.png" alt></p><p><img src="https://www.ichenfei.com/wp-content/uploads/2017/11/025b2a1366ab09d083610fd104729a60.png" alt><br>服务器重启后，下面两句需要重新执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo sslocal -c /etc/ssclient.conf -d start</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">"http://127.0.0.1:8123/"</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">"http://127.0.0.1:8123/"</span></span><br></pre></td></tr></table></figure><p>取消代理:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unset http_proxy</span><br><span class="line">unset https_proxy</span><br></pre></td></tr></table></figure><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h4><ul><li><a href="http://blog.forecho.com/ubuntu-use-shadowsocks-and-privoxy.html" target="_blank" rel="noopener">Ubuntu 使用 ShadowSocks + Privoxy 代理</a></li><li><a href="https://linux.cn/article-7119-1.html" target="_blank" rel="noopener">五大开源 Web 代理服务器横评：Squid、Privoxy、Varnish、Polipo、Tinyproxy</a></li><li><a href="https://jingsam.github.io/2016/05/08/setup-shadowsocks-http-proxy-on-ubuntu-server.html" target="_blank" rel="noopener">Ubuntu server命令行配置shadowsocks全局代理</a></li><li><a href="https://www.igfw.net/archives/947" target="_blank" rel="noopener">使用Privoxy、Polipo、3proxy转化Sock5代理为Http代理</a></li></ul><h2 id="使用supervisor管理shadowsocks进程"><a href="#使用supervisor管理shadowsocks进程" class="headerlink" title="使用supervisor管理shadowsocks进程"></a>使用<code>supervisor</code>管理<code>shadowsocks</code>进程</h2><p>安装supervisor<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install supervisor</span><br></pre></td></tr></table></figure></p><p>添加ss配置文件</p><p>vim /etc/supervisor/conf.d/ss.conf<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[program:ss]</span><br><span class="line"><span class="built_in">command</span>=/usr/<span class="built_in">local</span>/bin/sslocal -c /etc/ssclient.conf</span><br><span class="line">user=root</span><br><span class="line">directory=/root</span><br><span class="line">stdout_logfile=/var/<span class="built_in">log</span>/supervisor/%(program_name)s-stdout.log</span><br><span class="line">stderr_logfile=/var/<span class="built_in">log</span>/supervisor/%(program_name)s-stderr.log</span><br><span class="line">killasgroup=<span class="literal">true</span></span><br><span class="line">stopasgroup=<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>使用<code>supervisor</code>启动ss:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo service supervisor restart</span><br><span class="line">sudo supervisorctl restart ss</span><br><span class="line"></span><br><span class="line">root@huang:~<span class="comment"># lsof -i :1080</span></span><br><span class="line">COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME</span><br><span class="line">sslocal 3148 root    3u  IPv4  33691      0t0  TCP localhost:socks (LISTEN)</span><br><span class="line">sslocal 3148 root    4u  IPv4  33692      0t0  UDP localhost:socks</span><br></pre></td></tr></table></figure></p><h2 id="为git协议设置代理"><a href="#为git协议设置代理" class="headerlink" title="为git协议设置代理"></a>为git协议设置代理</h2><h3 id="使用ProxyChains-NG"><a href="#使用ProxyChains-NG" class="headerlink" title="使用ProxyChains-NG"></a>使用ProxyChains-NG</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/rofl0r/proxychains-ng.git</span><br><span class="line"><span class="built_in">cd</span> proxychains-ng</span><br><span class="line">sudo ./configure</span><br><span class="line">sudo make &amp;&amp; make install</span><br></pre></td></tr></table></figure><!--cp ./src/proxychains.conf /etc/proxychains.confsed -i -e '/^#/d' -e '/^$/d' /etc/proxychains.conf将`socks4 127.0.0.1 9095`改为`socks5 127.0.0.1 1080`--><p>sudo vim /etc/proxychains.conf</p><p>添加如下配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">strict_chain</span><br><span class="line">proxy_dns </span><br><span class="line">remote_dns_subnet 224</span><br><span class="line">tcp_read_time_out 15000</span><br><span class="line">tcp_connect_time_out 8000</span><br><span class="line">localnet 127.0.0.0/255.0.0.0</span><br><span class="line">quiet_mode</span><br><span class="line"></span><br><span class="line">[ProxyList]</span><br><span class="line">socks5  127.0.0.1 1080</span><br></pre></td></tr></table></figure></p><p>在需要代理的命令前加上 <code>proxychains4</code> ，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxychains4 curl ip.sb</span><br><span class="line"></span><br><span class="line">proxychains4 git clone git://github.com/WordPress/WordPress.git</span><br></pre></td></tr></table></figure></p><h3 id="使用tsocks"><a href="#使用tsocks" class="headerlink" title="使用tsocks"></a>使用tsocks</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install tsocks</span><br><span class="line">vim /etc/tsocks.conf</span><br></pre></td></tr></table></figure><p>配置如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">local = 192.168.0.0/255.255.255.0</span><br><span class="line">local = 10.0.0.0/255.0.0.0</span><br><span class="line">path &#123;</span><br><span class="line">reaches = 150.0.0.0/255.255.0.0</span><br><span class="line">reaches = 150.1.0.0:80/255.255.0.0</span><br><span class="line">server = 10.1.7.25</span><br><span class="line">server_type = 5</span><br><span class="line">default_user = delius</span><br><span class="line">default_pass = hello</span><br><span class="line">&#125;</span><br><span class="line">server = 127.0.0.1</span><br><span class="line">server_type = 5</span><br><span class="line">server_port = 1080</span><br></pre></td></tr></table></figure></p><p>使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsocks curl ip.sb</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ubuntu 终端使用shadowsocks全局代理&lt;/p&gt;
    
    </summary>
    
    
      <category term="tools" scheme="http://blog.ichenfei.com/categories/tools/"/>
    
    
  </entry>
  
  <entry>
    <title> Ubuntu16.04搭建ngrok服务		</title>
    <link href="http://blog.ichenfei.com/2017/11/15/Ubuntu16.04%E6%90%AD%E5%BB%BAngrok%E6%9C%8D%E5%8A%A1/"/>
    <id>http://blog.ichenfei.com/2017/11/15/Ubuntu16.04%E6%90%AD%E5%BB%BAngrok%E6%9C%8D%E5%8A%A1/</id>
    <published>2017-11-15T12:19:56.000Z</published>
    <updated>2019-11-23T18:38:13.615Z</updated>
    
    <content type="html"><![CDATA[<p>Ubuntu16.04搭建ngrok服务<br><a id="more"></a></p><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖:"></a>安装依赖:</h2><pre><code>sudo apt-get install build-essential golang mercurial git</code></pre><p>如果你的 Ubuntu版本是14.04及以下，<code>apt-get install golang</code>安装的<code>golang</code>是1.2版本的,而ngrok要求<code>golang</code>版本大于1.3,导致编译客户端时报错：</p><pre><code>src/github.com/gorilla/websocke... undefined: sync.Poolmake: * [client] Error 2</code></pre><p>参考DigitalOcean给的<a href="https://www.digitalocean.com/community/tutorials/how-to-install-go-1-6-on-ubuntu-14-04" target="_blank" rel="noopener">教程</a>手动安装golang:</p><pre><code>sudo curl -O https://storage.googleapis.com/golang/go1.6.linux-amd64.tar.gzsudo tar -zxvf go1.6.linux-amd64.tar.gzsudo mv go /usr/localecho &quot;export PATH=\$PATH:/usr/local/go/bin&quot; &gt;&gt; ~/.profilesource ~/.profile</code></pre><h2 id="编译ngrok服务端与客户端"><a href="#编译ngrok服务端与客户端" class="headerlink" title="编译ngrok服务端与客户端"></a>编译ngrok服务端与客户端</h2><p>从<code>github</code>获取ngrok源码</p><pre><code>git clone https://github.com/inconshreveable/ngrok.git ngrok</code></pre><p>生成并替换源码里默认的<code>ssl</code>证书</p><pre><code>cd ngrokexport NGROK_DOMAIN=&quot;ngrok.ichenfei.com&quot;openssl genrsa -out base.key 2048openssl req -new -x509 -nodes -key base.key -days 10000 -subj &quot;/CN=$NGROK_DOMAIN&quot; -out base.pemopenssl genrsa -out server.key 2048openssl req -new -key server.key -subj &quot;/CN=$NGROK_DOMAIN&quot; -out server.csropenssl x509 -req -in server.csr -CA base.pem -CAkey base.key -CAcreateserial -days 10000 -out server.crtcp base.pem assets/client/tls/ngrokroot.crt</code></pre><h3 id="编译服务端"><a href="#编译服务端" class="headerlink" title="编译服务端:"></a>编译服务端:</h3><pre><code>sudo make release-server</code></pre><h3 id="编译客户端"><a href="#编译客户端" class="headerlink" title="编译客户端"></a>编译客户端</h3><pre><code>Windows 64位:sudo GOOS=darwin GOARCH=amd64 make release-clientWindows 32位:sudo GOOS=darwin GOARCH=386 make release-clientmac osx 64位：sudo GOOS=darwin GOARCH=amd64 make release-clientlinux：sudo GOOS=linux GOARCH=amd64 make release-client</code></pre><p>编译完成后再<code>ngrok/bin</code>目录会出现一个类似于的<code>windows_amd64</code>文件夹,里面有客户端 <code>cd bin/windows_amd64 &amp;&amp; sz ngrox</code> 保存到本机</p><h2 id="运行ngrok服务"><a href="#运行ngrok服务" class="headerlink" title="运行ngrok服务:"></a>运行ngrok服务:</h2><pre><code>tmuxsudo ./bin/ngrokd -tlsKey=server.key -tlsCrt=server.crt -domain=&quot;ngrok.ichenfei.com&quot; -httpAddr=&quot;:8000&quot; -httpsAddr=&quot;:8001&quot; -tunnelAddr=&quot;:4000&quot;-domain: 指定域名,需要与生成证书使用的域名一致-httpAddr: 指定http端口(需要是一个未被占用的端口,可随意指定)-httpsAddr: 指定https端口-tunnelAddr ngrok通道的端口号，这个端口是Ngrok用来通信的，所以这个端口在服务器上和客户端上设置必须要对应才可以正常的链接，默认不填写是4443</code></pre><h2 id="客户端运行"><a href="#客户端运行" class="headerlink" title="客户端运行"></a>客户端运行</h2><p>写一个简单的配置文件，随意命名如 <code>ngrok.cfg</code>：</p><pre><code>server_addr: ngrok.ichenfei.com:4443trust_host_root_certs: false</code></pre><p>指定子域名、要转发的协议和端口，以及配置文件，运行客户端：</p><pre><code>ngrok.exe -config=ngrok.cfg -subdomain=test -proto=http 80-config 指定配置文件-proto 指定协议-subdomain 指定子域名 (需要对域名做泛解析)</code></pre><p>没有在服务端指定的端口会随意选择一个端口转发 ngrok会随意选择一个端口对本机的22端口进行转发 如果想一次性转发多个端口或者想指定远程的对应端口，需要完善ngrok.cfg</p><pre><code>server_addr: ngrok.domain.com:4000trust_host_root_certs: falsetunnels: ssh:  remote_port: 1122  proto:   tcp: 22 ss:  emote_port: 1080  proto:   tcp: 1080 ftp:  remote_port: 20  proto:   tcp: 20 http:  subdomain: www  proto:   http: 80   https: 192.168.240.3:8080</code></pre><p>启动特定的转发tunnel:</p><pre><code>./ngrok -config ngrok.cfg start ssh当然也可以将所有配置全部转发./ngrok -config ngrok.cfg start-all</code></pre><p><img src="https://www.ichenfei.com/wp-content/uploads/2017/11/aa2b3313dc552dcb323300728c1a88fa.png" alt="ngrok转发http协议"> <img src="https://www.ichenfei.com/wp-content/uploads/2017/11/f2b2059e69955d95000f314f9cf9331c.png" alt="ngrok转发http协议1"> <img src="https://www.chengyingyou.com/article/7" alt="Ngrok内网穿透"> 由于ngrok可以转发所有tcp协议,所以<code>22</code>,<code>3389</code>,<code>3306</code>等端口也可以通过ngrok转发到公网,使用<code>-proto=tcp</code>指定<code>tcp</code>协议</p><pre><code>./ngrok -config=ngrok.cfg -proto=tcp 22</code></pre><p><img src="https://www.ichenfei.com/wp-content/uploads/2017/11/1b0e2a7228ea244804c6fa4abe5a723c.png" alt> 如果不搭建自己的ngrok服务,也可以到<code>ngork.com</code><a href="https://ngrok.com/download" target="_blank" rel="noopener">下载</a>官方提供的ngrok客户端。ngrok官网提供的服务基于<code>ngrok 2.x</code>(未开源),使用github源码搭建的服务器基于<code>ngrok 1.x</code>,用法有很大不同,可以参考给的<code>EXAMPLES</code>使用</p><pre><code>EXAMPLES:    ngrok http 80                    # secure public URL for port 80 web server    ngrok http -subdomain=baz 8080   # port 8080 available at baz.ngrok.io    ngrok http foo.dev:80            # tunnel to host:port instead of localhost    ngrok tcp 22                     # tunnel arbitrary TCP traffic to port 22    ngrok tls -hostname=foo.com 443  # TLS traffic for foo.com to port 443    ngrok start foo bar baz          # start tunnels from the configuration file</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Ubuntu16.04搭建ngrok服务&lt;br&gt;
    
    </summary>
    
    
      <category term="tools" scheme="http://blog.ichenfei.com/categories/tools/"/>
    
    
  </entry>
  
  <entry>
    <title> Python使用virtualenv和virtualenvwrapper		</title>
    <link href="http://blog.ichenfei.com/2017/11/10/Python%E4%BD%BF%E7%94%A8virtualenv%E5%92%8Cvirtualenvwrapper/"/>
    <id>http://blog.ichenfei.com/2017/11/10/Python%E4%BD%BF%E7%94%A8virtualenv%E5%92%8Cvirtualenvwrapper/</id>
    <published>2017-11-10T11:36:37.000Z</published>
    <updated>2019-11-23T18:27:10.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="virtualenv-介绍"><a href="#virtualenv-介绍" class="headerlink" title="virtualenv 介绍"></a>virtualenv 介绍</h2><blockquote><p>在使用 Python 开发的过程中，工程一多，难免会碰到不同的工程依赖不同版本的库的问题；亦或者是在开发过程中不想让物理环境里充斥各种各样的库，引发未来的依赖灾难。此时，我们需要对于不同的工程使用不同的虚拟环境来保持开发环境以及宿主环境的清洁。virtualenv便是一个可以帮助我们管理不同 Python 环境的绝好工具。 可以在系统中建立多个不同并且相互不干扰的虚拟环境。</p></blockquote><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>[code lang=bash] pip install virtualenv [/code]</p><h3 id="新建虚拟环境"><a href="#新建虚拟环境" class="headerlink" title="新建虚拟环境"></a>新建虚拟环境</h3><p>[code lang=bash] virtualenv scrapytest [/code]</p><h3 id="指定python版本"><a href="#指定python版本" class="headerlink" title="指定python版本"></a>指定python版本</h3><p>[code lang=bash] virtualenv -p 指定python版本路径 [/code]</p><h3 id="激活环境"><a href="#激活环境" class="headerlink" title="激活环境"></a>激活环境</h3><p>[code lang=bash] source scrapytest/bin/activate # windows 是在Scripts文件夹下deactivate.bat [/code]</p><h3 id="退出虚拟环境"><a href="#退出虚拟环境" class="headerlink" title="退出虚拟环境"></a>退出虚拟环境</h3><p>[code lang=bash] deactivate [/code]</p><h2 id="使用-virtualenvwrapper-管理虚拟环境"><a href="#使用-virtualenvwrapper-管理虚拟环境" class="headerlink" title="使用 virtualenvwrapper 管理虚拟环境"></a>使用 virtualenvwrapper 管理虚拟环境</h2><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>[code lang=bash] pip install virtualenvwrapper # windows下使用: pip install virtualenvwrapper-win [/code]</p><h2 id="添加环境变量-WORKON-HOME"><a href="#添加环境变量-WORKON-HOME" class="headerlink" title="添加环境变量: WORKON_HOME"></a>添加环境变量: WORKON_HOME</h2><p>Linux: [code lang=bash] vim /etc/profile 在最后添加: export WORKON_HOME=$HOME/.virtualenvs source /usr/local/bin/virtualenvwrapper.sh source /etc/profile #使配置立即生效 virtualenvwrapper.user_scripts creating /root/.virtualenvs/premkproject virtualenvwrapper.user_scripts creating /root/.virtualenvs/postmkproject virtualenvwrapper.user_scripts creating /root/.virtualenvs/initialize virtualenvwrapper.user_scripts creating /root/.virtualenvs/premkvirtualenv virtualenvwrapper.user_scripts creating /root/.virtualenvs/postmkvirtualenv virtualenvwrapper.user_scripts creating /root/.virtualenvs/prermvirtualenv virtualenvwrapper.user_scripts creating /root/.virtualenvs/postrmvirtualenv virtualenvwrapper.user_scripts creating /root/.virtualenvs/predeactivate virtualenvwrapper.user_scripts creating /root/.virtualenvs/postdeactivate virtualenvwrapper.user_scripts creating /root/.virtualenvs/preactivate virtualenvwrapper.user_scripts creating /root/.virtualenvs/postactivate virtualenvwrapper.user_scripts creating /root/.virtualenvs/get_env_details [/code] Windows: <img src="https://www.ichenfei.com/wp-content/uploads/2017/11/dce990ec141f4d3cb0a5bd28e44f1fbe.png" alt></p><h2 id="命令列表"><a href="#命令列表" class="headerlink" title="命令列表"></a>命令列表</h2><ul><li>workon:列出虚拟环境列表</li><li>workon [虚拟环境名称]:切换虚拟环境</li><li>lsvirtualenv:同workon</li><li>mkvirtualenv :新建虚拟环境</li><li>rmvirtualenv :删除虚拟环境</li><li>deactivate: 离开虚拟环境</li></ul><p>参考链接:</p><ul><li><a href="https://segmentfault.com/a/1190000004079979" target="_blank" rel="noopener">聊聊 virtualenv 和 virtualenvwrapper 实践</a></li><li><a href="http://www.jianshu.com/p/dcfe4cab4933" target="_blank" rel="noopener">virtualenvwrapper-win安装</a></li><li><a href="http://blog.csdn.net/shaququ/article/details/54292043" target="_blank" rel="noopener">windows下搭建virtualenv、virtualenvwrapper虚拟环境</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;virtualenv-介绍&quot;&gt;&lt;a href=&quot;#virtualenv-介绍&quot; class=&quot;headerlink&quot; title=&quot;virtualenv 介绍&quot;&gt;&lt;/a&gt;virtualenv 介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在使用 Python 开发的过程中，工程一多，难免会碰到不同的工程依赖不同版本的库的问题；亦或者是在开发过程中不想让物理环境里充斥各种各样的库，引发未来的依赖灾难。此时，我们需要对于不同的工程使用不同的虚拟环境来保持开发环境以及宿主环境的清洁。virtualenv便是一个可以帮助我们管理不同 Python 环境的绝好工具。 可以在系统中建立多个不同并且相互不干扰的虚拟环境。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.ichenfei.com/categories/Python/"/>
    
    
      <category term="virtualenv" scheme="http://blog.ichenfei.com/tags/virtualenv/"/>
    
      <category term="virtualenvwrapper" scheme="http://blog.ichenfei.com/tags/virtualenvwrapper/"/>
    
  </entry>
  
  <entry>
    <title> 几款用于穿透内网的代理工具		</title>
    <link href="http://blog.ichenfei.com/2017/11/08/%E5%87%A0%E6%AC%BE%E7%94%A8%E4%BA%8E%E7%A9%BF%E9%80%8F%E5%86%85%E7%BD%91%E7%9A%84%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://blog.ichenfei.com/2017/11/08/%E5%87%A0%E6%AC%BE%E7%94%A8%E4%BA%8E%E7%A9%BF%E9%80%8F%E5%86%85%E7%BD%91%E7%9A%84%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7/</id>
    <published>2017-11-08T07:21:44.000Z</published>
    <updated>2019-11-23T17:55:29.105Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><blockquote><p>当内网中的主机没有外网IP地址要被外网稳定访问时,可以使用反向代理工具将主机端口映射出去,从而通过访问外网就能访问到内网中的主机</p></blockquote><a id="more"></a><h2 id="ngrok"><a href="#ngrok" class="headerlink" title="ngrok"></a>ngrok</h2><blockquote><p>ngrok 是一个反向代理，通过在公共的端点和本地运行的 Web 服务器之间建立一个安全的通道。ngrok 可捕获和分析所有通道上的流量，便于后期分析和重放</p></blockquote><p><img src="https://www.ichenfei.com/wp-content/uploads/2017/11/9249f4129b5274569da3cc7576b3e33d.png" alt></p><ul><li><a href="https://ngrok.com/" target="_blank" rel="noopener">ngrok官网</a></li><li><a href="https://github.com/inconshreveable/ngrok" target="_blank" rel="noopener">github: inconshreveable/ngrok</a></li><li>自己搭建ngrok服务：<ul><li>参考:</li><li><a href="https://imququ.com/post/self-hosted-ngrokd.html" target="_blank" rel="noopener">搭建 ngrok 服务实现内网穿透 – imququ.com</a></li><li><a href="https://zhyack.github.io/posts/2017_04_07-Ngrok.html" target="_blank" rel="noopener">内网穿透——ngrok的搭建与使用 – zhyack.github.io</a></li><li><a href="http://blog.just4fun.site/build-ngrok-server.html" target="_blank" rel="noopener">建ngrok服务（内网穿透） –blog.just4fun.site</a></li></ul></li></ul><p>ngrok官网提供的服务基于ngrok 2.x,而ngrok只开源了1.x的源码,要搭建ngrok服务只能使用1.x的客户端连接。</p><h2 id="lanproxy"><a href="#lanproxy" class="headerlink" title="lanproxy:"></a>lanproxy:</h2><blockquote><p>Lanproxy是一个将局域网个人电脑、服务器代理到公网的内网穿透工具 目前仅支持tcp流量转发，可支持任何tcp上层协议（访问内网网站、本地支付接口调试、微信小程序调试、ssh访问、远程桌面…）</p></blockquote><p><img src="https://www.ichenfei.com/wp-content/uploads/2017/11/7797ae475bcbb69d56ede9b046ce699c.png" alt></p><ul><li><a href="https://lanproxy.thingsglobal.org/" target="_blank" rel="noopener">lanproxy.thingsglobal.org</a></li><li><a href="https://github.com/ffay/lanproxy" target="_blank" rel="noopener">源代码 -- github</a></li><li><a href="https://github.com/ffay/lanproxy/files/1439965/proxy-server-0.1-beta.zip" target="_blank" rel="noopener">proxy-server-0.1-beta.zip</a></li><li><a href="https://lanproxy.thingsglobal.org/proxy-client-0.1-beta.zip" target="_blank" rel="noopener">proxy-client-0.1-beta.zip</a></li><li>lanproxy服务搭建<ul><li>参考:</li><li><a href="https://segmentfault.com/a/1190000011155909" target="_blank" rel="noopener">使用lanproxy进行内网穿透</a></li><li><a href="http://blog.csdn.net/xmtblog/article/details/77943159" target="_blank" rel="noopener">业余草推荐一款局域网（内网）穿透工具lanproxy</a></li></ul></li></ul><h2 id="lcx-exe"><a href="#lcx-exe" class="headerlink" title="lcx.exe"></a>lcx.exe</h2><p>[code lang=text] 服务端: lcx.exe -listen 51 33891 客户端: lcx.exe -slave 服务端ip 51 127.0.0.1 3389 这就用lcx.exe将客户端的3389转发到了服务端的33891上 [/code]</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;当内网中的主机没有外网IP地址要被外网稳定访问时,可以使用反向代理工具将主机端口映射出去,从而通过访问外网就能访问到内网中的主机&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="tools" scheme="http://blog.ichenfei.com/categories/tools/"/>
    
    
      <category term="lanproxy" scheme="http://blog.ichenfei.com/tags/lanproxy/"/>
    
      <category term="ngrok" scheme="http://blog.ichenfei.com/tags/ngrok/"/>
    
      <category term="内网穿透" scheme="http://blog.ichenfei.com/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title> 使用Python 进行各进制间转换		</title>
    <link href="http://blog.ichenfei.com/2017/10/31/%E4%BD%BF%E7%94%A8Python%20%E8%BF%9B%E8%A1%8C%E5%90%84%E8%BF%9B%E5%88%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/"/>
    <id>http://blog.ichenfei.com/2017/10/31/%E4%BD%BF%E7%94%A8Python%20%E8%BF%9B%E8%A1%8C%E5%90%84%E8%BF%9B%E5%88%B6%E9%97%B4%E8%BD%AC%E6%8D%A2/</id>
    <published>2017-10-31T04:01:25.000Z</published>
    <updated>2019-11-23T18:21:10.171Z</updated>
    
    <content type="html"><![CDATA[<ul><li>表示各进制的符号 -b：二进制 -o：八进制 -d：十进制 -x：十六进制</li></ul><a id="more"></a><p>bin()、oct()、hex()返回值均为字符串，且分别带有0b、0o、0x前缀。</p><h2 id="十进制转二进制："><a href="#十进制转二进制：" class="headerlink" title="十进制转二进制："></a>十进制转二进制：</h2><p>[python] In [6]: bin(192) Out[6]: ‘0b11000000’ In [7]: ‘{0:b}’.format(192) Out[7]: ‘11000000’ [/python]</p><h2 id="十进制转八进制："><a href="#十进制转八进制：" class="headerlink" title="十进制转八进制："></a>十进制转八进制：</h2><p>[python] In [42]: oct(192) Out[42]: ‘0300’ In [41]: ‘{0:o}’.format(192) Out[41]: ‘300’ [/python]</p><h2 id="十进制转十六进制："><a href="#十进制转十六进制：" class="headerlink" title="十进制转十六进制："></a>十进制转十六进制：</h2><p>[python] In [39]: hex(192) Out[39]: ‘0xc0’ In [40]: ‘{0:x}’.format(192) Out[40]: ‘c0’ [/python]</p><h2 id="n进制转10进制"><a href="#n进制转10进制" class="headerlink" title="n进制转10进制"></a>n进制转10进制</h2><p>[python] int(‘xxx’,n) 示例: In [5]: int(‘c0a83090’,16) Out[5]: 3232247952L λ ping 3232247952 正在 Ping 192.168.48.144 具有 32 字节的数据: 来自 192.168.48.144 的回复: 字节=32 时间&lt;1ms TTL=64 来自 192.168.48.144 的回复: 字节=32 时间&lt;1ms TTL=64 来自 192.168.48.144 的回复: 字节=32 时间&lt;1ms TTL=64 来自 192.168.48.144 的回复: 字节=32 时间&lt;1ms TTL=64 192.168.48.144 的 Ping 统计信息: 数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)， 往返行程的估计时间(以毫秒为单位): 最短 = 0ms，最长 = 0ms，平均 = 0ms [/python]</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;表示各进制的符号 -b：二进制 -o：八进制 -d：十进制 -x：十六进制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.ichenfei.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title> 使用scrapyd部署scrapy爬虫		</title>
    <link href="http://blog.ichenfei.com/2017/10/30/how-to-uses-crapyd/"/>
    <id>http://blog.ichenfei.com/2017/10/30/how-to-uses-crapyd/</id>
    <published>2017-10-30T13:39:49.000Z</published>
    <updated>2019-11-23T18:40:20.118Z</updated>
    
    <content type="html"><![CDATA[<p>使用scrapyd部署scrapy爬虫</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Scrapyd is a service for running Scrapy spiders. It allows you to deploy your Scrapy projects and control their spiders using a HTTP JSON API.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装<code>scrapyd</code>服务端(需要scrapy项目环境) [code lang=python] pip install scrapyd [/code] 安装 <code>scrapyd-deploy</code> (无需scrapy环境) [code lang=python] pip install scrapyd-client [/code] windows系统，在<code>c:\python27\Scripts</code>下生成的是<code>scrapyd-deploy</code>，无法直接在命令行里运行<code>scrapd-deploy</code> 配置文件位置: [code lang=bash] sudo find / -name default_scrapyd.conf /home/ubuntu/.virtualenvs/secarticle/lib/python2.7/site-packages/scrapyd/default_scrapyd.conf [/code]</p><h5 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h5><p>在<code>C:\python27\Scripts</code>下新建一个<code>scrapyd-deploy.bat</code>，文件内容如下： [code lang=cmd] @echo off C:\Python27\python C:\Python27\Scripts\scrapyd-deploy %* [/code]</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="开启scrapyd"><a href="#开启scrapyd" class="headerlink" title="开启scrapyd"></a>开启scrapyd</h3><p>终端运行:<code>scrapyd</code>开启<code>scrapyd</code>服务</p><h3 id="发布工程到scrapyd"><a href="#发布工程到scrapyd" class="headerlink" title="发布工程到scrapyd"></a>发布工程到scrapyd</h3><p>切换至到<code>scrapy</code>项目根目录,编辑<code>scrapy.cfg</code>, [code lang=text] 取消 # url = <a href="http://localhost:6800/前面的注释#" target="_blank" rel="noopener">http://localhost:6800/前面的注释#</a> [/code] <img src="https://www.ichenfei.com/wp-content/uploads/2017/10/0678af8c66e671232462916041dee39d.png" alt> 打包发布<code>scrapyd</code>项目: [code lang=text] scrapyd-deploy <target> -p <project> [/code]</project></target></p><ul><li><code>&lt;target&gt;</code>就是配置文件的<code>deploy</code>的名字，针对上面的配置就是<code>scearticle</code></li><li><code>&lt;project&gt;</code>是项目名<code>scrapyd</code>项目名,不输入则默认为<code>deploy</code>的名字</li></ul><p>部署完成之后，创建的scrapy项目中可以看到多了一个eggs的文件夹，以及里面的一些内容，里面所存放的就是scrapyd-deploy的工程打包成.egg的文件 <img src="https://www.ichenfei.com/wp-content/uploads/2017/10/2e3e75aea3ef2cde9615576f22ee531e.png" alt></p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="查看scrapyd运行状态"><a href="#查看scrapyd运行状态" class="headerlink" title="查看scrapyd运行状态"></a>查看<code>scrapyd</code>运行状态</h3><p>[code lang=bash] curl <a href="http://localhost:6800/daemonstatus.json" target="_blank" rel="noopener">http://localhost:6800/daemonstatus.json</a> 返回: {“status”: “ok”, “running”: 0, “finished”: 42, “pending”: 0, “node_name”: “VM-42-98-ubuntu”} [/code]</p><h3 id="创建爬虫任务"><a href="#创建爬虫任务" class="headerlink" title="创建爬虫任务"></a>创建爬虫任务</h3><p>[code lang=bash] curl <a href="http://localhost:6800/schedule.json" target="_blank" rel="noopener">http://localhost:6800/schedule.json</a> -d project=myproject -d spider=somespider 参数: project (string, required) - 项目名 spider (string, required) - 项目中的爬虫名 setting (string, optional) - 指定使用Scrapy设置 jobid (string, optional) - 指定jobid _version (string, optional) - 指定项目版本 示例: curl <a href="http://localhost:6800/schedule.json" target="_blank" rel="noopener">http://localhost:6800/schedule.json</a> -d project=SecArticleSpider -d spider=freebuf 返回: {“status”: “ok”, “jobid”: “7ea5ddc0bd7d11e7b256525400dc407e”, “node_name”: “VM-42-98-ubuntu”} [/code]</p><h3 id="取消正在运行的job"><a href="#取消正在运行的job" class="headerlink" title="取消正在运行的job"></a>取消正在运行的job</h3><p>[code lang=text] curl <a href="http://localhost:6800/cancel.json" target="_blank" rel="noopener">http://localhost:6800/cancel.json</a> -d project=myproject -d job=6487ec79947edab326d6db28a2d86511e8247444 返回: {“status”: “ok”, “prevstate”: “running”} [/code]</p><h3 id="列出项目"><a href="#列出项目" class="headerlink" title="列出项目:"></a>列出项目:</h3><p>[code lang=text] curl <a href="http://localhost:6800/listprojects.json" target="_blank" rel="noopener">http://localhost:6800/listprojects.json</a> 返回: {“status”: “ok”, “projects”: [“myproject”, “otherproject”]} [/code]</p><h3 id="列出爬虫"><a href="#列出爬虫" class="headerlink" title="列出爬虫:"></a>列出爬虫:</h3><p>[code lang=text] curl <a href="http://localhost:6800/listspiders.json?project=myproject" target="_blank" rel="noopener">http://localhost:6800/listspiders.json?project=myproject</a> 返回: {“status”: “ok”, “spiders”: [“spider1”, “spider2”, “spider3”]} [/code]</p><h3 id="列出job："><a href="#列出job：" class="headerlink" title="列出job："></a>列出job：</h3><p>[bash] curl <a href="http://localhost:6800/listjobs.json?project=myproject" target="_blank" rel="noopener">http://localhost:6800/listjobs.json?project=myproject</a> 示例返回: “status”: “ok”, “pending”: [{“id”: “78391cc0fcaf11e1b0090800272a6d06”, “spider”: “spider1”}], “running”: [{“id”: “422e608f9f28cef127b3d5ef93fe9399”, “spider”: “spider2”, “start_time”: “2012-09-12 10:14:03.594664”}], “finished”: [{“id”: “2f16646cfcaf11e1b0090800272a6d06”, “spider”: “spider3”, “start_time”: “2012-09-12 10:14:03.594664”, “end_time”: “2012-09-12 10:24:03.594664”}]} [/bash]</p><h3 id="删除项目"><a href="#删除项目" class="headerlink" title="删除项目:"></a>删除项目:</h3><p>[bash] curl <a href="http://localhost:6800/delproject.json" target="_blank" rel="noopener">http://localhost:6800/delproject.json</a> -d project=myproject 示例返回: {“status”: “ok”} [/bash] 更多支持的api： <a href="http://scrapyd.readthedocs.io/en/stable/api.html" target="_blank" rel="noopener">Scrapyd 官方支持手册</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用scrapyd部署scrapy爬虫&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.ichenfei.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title> Python抓取中文网页乱码问题		</title>
    <link href="http://blog.ichenfei.com/2016/10/21/python-error-coding-problem/"/>
    <id>http://blog.ichenfei.com/2016/10/21/python-error-coding-problem/</id>
    <published>2016-10-20T16:41:01.000Z</published>
    <updated>2019-11-23T18:19:53.987Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="text与-content的区别"><a href="#text与-content的区别" class="headerlink" title=".text与.content的区别"></a>.text与.content的区别</h2><p>requests的官方文档有这么一段:</p><blockquote><p>We can read the content of the server’s response. Consider the GitHub timeline again: &gt;&gt;&gt; import requests &gt;&gt;&gt; r = requests.get(‘<a href="https://api.github.com/events&#39;" target="_blank" rel="noopener">https://api.github.com/events&#39;</a>) &gt;&gt;&gt; r.text u’[{“repository”:{“open_issues”:0,”url”:”<a href="https://github.com/.." target="_blank" rel="noopener">https://github.com/..</a>. Requests will automatically decode content from the server. Most unicode charsets are seamlessly decoded. When you make a request, Requests makes educated guesses about the encoding of the response based on the HTTP headers. The text encoding guessed by Requests is used when you access r.text. You can find out what encoding Requests is using, and change it, using the r.encoding property: &gt;&gt;&gt; r.encoding ‘utf-8’ &gt;&gt;&gt; r.encoding = ‘ISO-8859-1’ If you change the encoding, Requests will use the new value of r.encoding whenever you call r.text. You might want to do this in any situation where you can apply special logic to work out what the encoding of the content will be. For example, HTTP and XML have the ability to specify their encoding in their body. In situations like this, you should use r.content to find the encoding, and then set r.encoding. This will let you use r.text with the correct encoding. Requests will also use custom encodings in the event that you need them. If you have created your own encoding and registered it with the codecs module, you can simply use the codec name as the value of r.encoding and Requests will handle the decoding for you.</p></blockquote><p>大意就是说，.text方法会猜网站编码,大部分网站都能蒙对,如果猜不对的话可以用 encoding 方法指定 response 的编码,上面的代码还可以写成 [python] url = “<a href="https://www.jisilu.cn/home/explore/sort\_type-new\_\_day-0__page-1&quot;" target="_blank" rel="noopener">https://www.jisilu.cn/home/explore/sort\_type-new\_\_day-0__page-1&quot;</a> html = requests.get(url,headers=headers) html.encoding = “utf-8” print html.text [/python] 而.content而高级一点,.content会自己去文本里面找是什么编码，而不是靠猜的。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;text与-content的区别&quot;&gt;&lt;a href=&quot;#text与-content的区别&quot; class=&quot;headerlink&quot; title=&quot;.text与.content的区别&quot;&gt;&lt;/a&gt;.text与.content的区别&lt;/
      
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.ichenfei.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title> 使用 Supervisor 管理进程		</title>
    <link href="http://blog.ichenfei.com/2016/09/22/use-supervisor-to-manage-process/"/>
    <id>http://blog.ichenfei.com/2016/09/22/use-supervisor-to-manage-process/</id>
    <published>2016-09-22T14:58:11.000Z</published>
    <updated>2019-11-23T18:37:54.316Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Supervisor 是基于 Python 的进程管理工具，只能运行在 Unix-Like 的系统上,Supervisor可以很方便的用来启动、重启、关闭进程。除了对单个进程的控制，还可以同时启动、关闭多个进程。</p></blockquote><a id="more"></a><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>Supervisor 有两个主要的组成部分：*   supervisord: 运行 Supervisor 时会启动一个supervisord进程，它负责启动所管理的进程，并将所管理的进程作为自己的子进程来启动，而且可以在所管理的进程出现崩溃时自动重启。  </p><ul><li><p>supervisorctl：是命令行管理工具，可以用来执行 stop、start、restart 等命令，来对这些子进程进行管理。  </p><h2 id="安装supervisor"><a href="#安装supervisor" class="headerlink" title="安装supervisor"></a>安装supervisor</h2><p>[bash] pip install supervisor [/bash] 也可以使用yum或apt-get安装,ubuntu下更建议用或apt-get安装。</p><h2 id="配置supervisor"><a href="#配置supervisor" class="headerlink" title="配置supervisor"></a>配置supervisor</h2><p>[bash] mkdir -p /etc/supervisor/conf.d echo_supervisord_conf &gt; /etc/supervisor/supervisord.conf vim /etc/supervisor/supervisord.conf [/bash] 修改: [bash] [include] files = /etc/supervisor/conf.d/*.conf [/bash]</p><h2 id="启动-Supervisor服务"><a href="#启动-Supervisor服务" class="headerlink" title="启动 Supervisor服务"></a>启动 Supervisor服务</h2><p>[bash] supervisord -c /etc/supervisor/supervisord.conf [/bash] 其中 -c 指定配置文件,如果没有指定,默认在以下目录查找： [bash] $CWD/supervisord.conf $CWD/etc/supervisord.conf /etc/supervisord.conf /etc/supervisor/supervisord.conf (since Supervisor 3.3.0) ../etc/supervisord.conf (Relative to the executable) ../supervisord.conf (Relative to the executable) [/bash] $CWD表示运行supervisord程序的目录。</p><h2 id="program-配置"><a href="#program-配置" class="headerlink" title="program 配置:"></a>program 配置:</h2><p>示例: [bash] cat /etc/supervisor/conf.d/shadowsocks.conf [program:shadowsocks] command=ssserver -c /etc/shadowsocks.json autostart=true autorestart=true user=root log_stderr=true logfile=/var/log/shadowsocks.log killasgroup=true stopasgroup=true [/bash]</p><h2 id="supervisorctl-交互终端"><a href="#supervisorctl-交互终端" class="headerlink" title="supervisorctl 交互终端:"></a>supervisorctl 交互终端:</h2><p>[bash] root@hhf:~# supervisorctl shadowsocks RUNNING pid 1667, uptime 0:00:08 supervisor&gt; help default commands (type help <topic>): ===================================== add clear fg open quit remove restart start stop update avail exit maintail pid reload reread shutdown status tail version [/bash] 注: Supervisor只能管理非daemon的进程，也就是说Supervisor不能管理守护进程。否则提示Exited too quickly (process log may have details)异常。 <strong>supervisord.conf</strong> 配置文件详细说明: [bash] [unix_http_server] file=/tmp/supervisor.sock ;UNIX socket 文件，supervisorctl 会使用,建议修改为/var/run/supervisor.sock ;chmod=0700 ;socket文件的mode，默认是0700 ;chown=nobody:nogroup ;socket文件的owner，格式：uid:gid ;[inet_http_server] ;HTTP服务器，提供web管理界面 ;port=127.0.0.1:9001 ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性 ;username=user ;登录管理后台的用户名 ;password=123 ;登录管理后台的密码 [supervisord] logfile=/tmp/supervisord.log ;日志文件，默认是 $CWD/supervisord.log logfile_maxbytes=50MB ;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小 logfile_backups=10 ;日志文件保留备份数量默认10，设为0表示不备份 loglevel=info ;日志级别，默认info，其它: debug,warn,trace pidfile=/tmp/supervisord.pid ;pid 文件 nodaemon=false ;是否在前台启动，默认是false，即以 daemon 的方式启动 minfds=1024 ;可以打开的文件描述符的最小值，默认 1024 minprocs=200 ;可以打开的进程数的最小值，默认 200 [supervisorctl] serverurl=unix:///tmp/supervisor.sock ;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致 ;serverurl=<a href="http://127.0.0.1:9001" target="_blank" rel="noopener">http://127.0.0.1:9001</a> ; 通过HTTP的方式连接supervisord ; [program:xx]是被管理的进程配置参数，xx是进程的名称 [program:xx] command=xxxxxxxxxxx ; 程序启动命令 autostart=true ; 在supervisord启动的时候也自动启动 startsecs=10 ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒 autorestart=true ; 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启 startretries=3 ; 启动失败自动重试次数，默认是3 user=tomcat ; 用哪个用户启动进程，默认是root priority=999 ; 进程启动优先级，默认999，值小的优先启动 redirect_stderr=true ; 把stderr重定向到stdout，默认false stdout_logfile_maxbytes=20MB ; stdout 日志文件大小，默认50MB stdout_logfile_backups = 20 ; stdout 日志文件备份数，默认是10 ; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件） stdout_logfile=/a/path ; 输出日志目录 ;stderr_logfile=/a/path ; 错误日志目录 ;stderr_logfile_maxbytes=1MB ; stderr 日志文件大小，默认50MB ;stderr_logfile_backups ; # stderr 日志文件备份数，默认是10 stopasgroup=false ;默认为false,进程被杀死时，是否向这个进程组发送stop信号，包括子进程 killasgroup=false ;默认为false，向进程组发送kill信号，包括子进程 ;包含其它配置文件 [include] files = relative/directory/<em>.ini ;可以指定一个或多个以.ini结束的配置文件,多个路径用空格隔开 [/bash] 更多配置说明参考: <a href="http://supervisord.org/configuration.html" target="_blank" rel="noopener">http://supervisord.org/configuration.html</a> [bash] [unix_http_server] file=/tmp/supervisor.sock ; socket文件的路径，supervisorctl用XML_RPC和supervisord通信就是通过它进行 的。如果不设置的话，supervisorctl也就不能用了 不设置的话，默认为none。 非必须设置 ;chmod=0700 ; 这个简单，就是修改上面的那个socket文件的权限为0700 不设置的话，默认为0700。 非必须设置 ;chown=nobody:nogroup ; 这个一样，修改上面的那个socket文件的属组为user.group 不设置的话，默认为启动supervisord进程的用户及属组。非必须设置 ;username=user ; 使用supervisorctl连接的时候，认证的用户 不设置的话，默认为不需要用户。 非必须设置 ;password=123 ; 和上面的用户名对应的密码，可以直接使用明码，也可以使用SHA加密 如：{SHA}82ab876d1387bfafe46cc1c8a2ef074eae50cb1d 默认不设置。。。非必须设置 ;[inet_http_server] ; 侦听在TCP上的socket，Web Server和远程的supervisorctl都要用到他 不设置的话，默认为不开启。非必须设置 ;port=127.0.0.1:9001 ; 这个是侦听的IP和端口，侦听所有IP用 :9001或</em>:9001。 这个必须设置，只要上面的[inet_http_server]开启了，就必须设置它 ;username=user ; 这个和上面的uinx_http_server一个样。非必须设置 ;password=123 ; 这个也一个样。非必须设置 [supervisord] ;这个主要是定义supervisord这个服务端进程的一些参数的 这个必须设置，不设置，supervisor就不用干活了 logfile=/tmp/supervisord.log ; 这个是supervisord这个主进程的日志路径，注意和子进程的日志不搭嘎。 默认路径$CWD/supervisord.log，$CWD是当前目录。。非必须设置 logfile_maxbytes=50MB ; 这个是上面那个日志文件的最大的大小，当超过50M的时候，会生成一个新的日 志文件。当设置为0时，表示不限制文件大小 默认值是50M，非必须设置。 logfile_backups=10 ; 日志文件保持的数量，上面的日志文件大于50M时，就会生成一个新文件。文件 数量大于10时，最初的老文件被新文件覆盖，文件数量将保持为10 当设置为0时，表示不限制文件的数量。 默认情况下为10。。。非必须设置 loglevel=info ; 日志级别，有critical, error, warn, info, debug, trace, or blather等 默认为info。。。非必须设置项 pidfile=/tmp/supervisord.pid ; supervisord的pid文件路径。 默认为$CWD/supervisord.pid。。。非必须设置 nodaemon=false ; 如果是true，supervisord进程将在前台运行 默认为false，也就是后台以守护进程运行。。。非必须设置 minfds=1024 ; 这个是最少系统空闲的文件描述符，低于这个值supervisor将不会启动。 系统的文件描述符在这里设置cat /proc/sys/fs/file-max 默认情况下为1024。。。非必须设置 minprocs=200 ; 最小可用的进程描述符，低于这个值supervisor也将不会正常启动。 ulimit -u这个命令，可以查看linux下面用户的最大进程数 默认为200。。。非必须设置 ;umask=022 ; 进程创建文件的掩码 默认为022。。非必须设置项 ;user=chrism ; 这个参数可以设置一个非root用户，当我们以root用户启动supervisord之后。 我这里面设置的这个用户，也可以对supervisord进行管理 默认情况是不设置。。。非必须设置项 ;identifier=supervisor ; 这个参数是supervisord的标识符，主要是给XML_RPC用的。当你有多个 supervisor的时候，而且想调用XML_RPC统一管理，就需要为每个 supervisor设置不同的标识符了 默认是supervisord。。。非必需设置 ;directory=/tmp ; 这个参数是当supervisord作为守护进程运行的时候，设置这个参数的话，启动 supervisord进程之前，会先切换到这个目录 默认不设置。。。非必须设置 ;nocleanup=true ; 这个参数当为false的时候，会在supervisord进程启动的时候，把以前子进程 产生的日志文件(路径为AUTO的情况下)清除掉。有时候咱们想要看历史日志，当 然不想日志被清除了。所以可以设置为true 默认是false，有调试需求的同学可以设置为true。。。非必须设置 ;childlogdir=/tmp ; 当子进程日志路径为AUTO的时候，子进程日志文件的存放路径。 默认路径是这个东西，执行下面的这个命令看看就OK了，处理的东西就默认路径 python -c “import tempfile;print tempfile.gettempdir()” 非必须设置 ;environment=KEY=”value” ; 这个是用来设置环境变量的，supervisord在linux中启动默认继承了linux的 环境变量，在这里可以设置supervisord进程特有的其他环境变量。 supervisord启动子进程时，子进程会拷贝父进程的内存空间内容。 所以设置的 这些环境变量也会被子进程继承。 小例子：environment=name=”haha”,age=”hehe” 默认为不设置。。。非必须设置 ;strip_ansi=false ; 这个选项如果设置为true，会清除子进程日志中的所有ANSI 序列。什么是ANSI 序列呢？就是我们的\n,\t这些东西。 默认为false。。。非必须设置 ; the below section must remain in the config file for RPC ; (supervisorctl/web interface) to work, additional interfaces may be ; added by defining them in separate rpcinterface: sections [rpcinterface:supervisor] ;这个选项是给XML_RPC用的，当然你如果想使用supervisord或者web server 这 个选项必须要开启的 supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface [supervisorctl] ;这个主要是针对supervisorctl的一些配置 serverurl=unix:///tmp/supervisor.sock ; 这个是supervisorctl本地连接supervisord的时候，本地UNIX socket 路径，注意这个是和前面的[unix_http_server]对应的 默认值就是unix:///tmp/supervisor.sock。。非必须设置 ;serverurl=<a href="http://127.0.0.1:9001" target="_blank" rel="noopener">http://127.0.0.1:9001</a> ; 这个是supervisorctl远程连接supervisord的时候，用到的TCP socket路径 注意这个和前面的[inet_http_server]对应 默认就是<a href="http://127.0.0.1:9001。。。非必须项" target="_blank" rel="noopener">http://127.0.0.1:9001。。。非必须项</a> ;username=chris ; 用户名 默认空。。非必须设置 ;password=123 ; 密码 默认空。。非必须设置 ;prompt=mysupervisor ; 输入用户名密码时候的提示符 默认supervisor。。非必须设置 ;history_file=~/.sc_history ; 这个参数和shell中的history类似，我们可以用上下键来查找前面执行过的命令 默认是no file的。。所以我们想要有这种功能，必须指定一个文件。。。非 必须设置 ; The below sample program section shows all possible program subsection values, ; create one or more ‘real’ program: sections to be able to control them under ; supervisor. ;[program:theprogramname] ;这个就是咱们要管理的子进程了，”:”后面的是名字，最好别乱写和实际进程 有点关联最好。这样的program我们可以设置一个或多个，一个program就是 要被管理的一个进程 ;command=/bin/cat ; 这个就是我们的要启动进程的命令路径了，可以带参数 例子：/home/test.py -a ‘hehe’ 有一点需要注意的是，我们的command只能是那种在终端运行的进程，不能是 守护进程。这个想想也知道了，比如说command=service httpd start。 httpd这个进程被linux的service管理了，我们的supervisor再去启动这个命令 这已经不是严格意义的子进程了。 这个是个必须设置的项 ;process_name=%(program_name)s ; 这个是进程名，如果我们下面的numprocs参数为1的话，就不用管这个参数 了，它默认值%(program_name)s也就是上面的那个program冒号后面的名字， 但是如果numprocs为多个的话，那就不能这么干了。想想也知道，不可能每个 进程都用同一个进程名吧。 ;numprocs=1 ; 启动进程的数目。当不为1时，就是进程池的概念，注意process_name的设置 默认为1 。。非必须设置 ;directory=/tmp ; 进程运行前，会前切换到这个目录 默认不设置。。。非必须设置 ;umask=022 ; 进程掩码，默认none，非必须 ;priority=999 ; 子进程启动关闭优先级，优先级低的，最先启动，关闭的时候最后关闭 默认值为999 。。非必须设置 ;autostart=true ; 如果是true的话，子进程将在supervisord启动后被自动启动 默认就是true 。。非必须设置 ;autorestart=unexpected ; 这个是设置子进程挂掉后自动重启的情况，有三个选项，false,unexpected 和true。如果为false的时候，无论什么情况下，都不会被重新启动， 如果为unexpected，只有当进程的退出码不在下面的exitcodes里面定义的退 出码的时候，才会被自动重启。当为true的时候，只要子进程挂掉，将会被无 条件的重启 ;startsecs=1 ; 这个选项是子进程启动多少秒之后，此时状态如果是running，则我们认为启 动成功了 默认值为1 。。非必须设置 ;startretries=3 ; 当进程启动失败后，最大尝试启动的次数。。当超过3次后，supervisor将把 此进程的状态置为FAIL 默认值为3 。。非必须设置 ;exitcodes=0,2 ; 注意和上面的的autorestart=unexpected对应。。exitcodes里面的定义的 退出码是expected的。 ;stopsignal=QUIT ; 进程停止信号，可以为TERM, HUP, INT, QUIT, KILL, USR1, or USR2等信号 默认为TERM 。。当用设定的信号去干掉进程，退出码会被认为是expected 非必须设置 ;stopwaitsecs=10 ; 这个是当我们向子进程发送stopsignal信号后，到系统返回信息 给supervisord，所等待的最大时间。 超过这个时间，supervisord会向该 子进程发送一个强制kill的信号。 默认为10秒。。非必须设置 ;stopasgroup=false ; 这个东西主要用于，supervisord管理的子进程，这个子进程本身还有 子进程。那么我们如果仅仅干掉supervisord的子进程的话，子进程的子进程 有可能会变成孤儿进程。所以咱们可以设置可个选项，把整个该子进程的 整个进程组都干掉。 设置为true的话，一般killasgroup也会被设置为true。 需要注意的是，该选项发送的是stop信号 默认为false。。非必须设置。。 ;killasgroup=false ; 这个和上面的stopasgroup类似，不过发送的是kill信号 ;user=chrism ; 如果supervisord是root启动，我们在这里设置这个非root用户，可以用来 管理该program 默认不设置。。。非必须设置项 ;redirect_stderr=true ; 如果为true，则stderr的日志会被写入stdout日志文件中 默认为false，非必须设置 ;stdout_logfile=/a/path ; 子进程的stdout的日志路径，可以指定路径，AUTO，none等三个选项。 设置为none的话，将没有日志产生。设置为AUTO的话，将随机找一个地方 生成日志文件，而且当supervisord重新启动的时候，以前的日志文件会被 清空。当 redirect_stderr=true的时候，sterr也会写进这个日志文件 ;stdout_logfile_maxbytes=1MB ; 日志文件最大大小，和[supervisord]中定义的一样。默认为50 ;stdout_logfile_backups=10 ; 和[supervisord]定义的一样。默认10 ;stdout_capture_maxbytes=1MB ; 这个东西是设定capture管道的大小，当值不为0的时候，子进程可以从stdout 发送信息，而supervisor可以根据信息，发送相应的event。 默认为0，为0的时候表达关闭管道。。。非必须项 ;stdout_events_enabled=false ; 当设置为ture的时候，当子进程由stdout向文件描述符中写日志的时候，将 触发supervisord发送PROCESS_LOG_STDOUT类型的event 默认为false。。。非必须设置 ;stderr_logfile=/a/path ; 这个东西是设置stderr写的日志路径，当redirect_stderr=true。这个就不用 设置了，设置了也是白搭。因为它会被写入stdout_logfile的同一个文件中 默认为AUTO，也就是随便找个地存，supervisord重启被清空。。非必须设置 ;stderr_logfile_maxbytes=1MB ; 这个出现好几次了，就不重复了 ;stderr_logfile_backups=10 ; 这个也是 ;stderr_capture_maxbytes=1MB ; 这个一样，和stdout_capture一样。 默认为0，关闭状态 ;stderr_events_enabled=false ; 这个也是一样，默认为false ;environment=A=”1”,B=”2” ; 这个是该子进程的环境变量，和别的子进程是不共享的 ;serverurl=AUTO ; ; The below sample eventlistener section shows all possible ; eventlistener subsection values, create one or more ‘real’ ; eventlistener: sections to be able to handle event notifications ; sent by supervisor. ;[eventlistener:theeventlistenername] ;这个东西其实和program的地位是一样的，也是suopervisor启动的子进 程，不过它干的活是订阅supervisord发送的event。他的名字就叫 listener了。我们可以在listener里面做一系列处理，比如报警等等 楼主这两天干的活，就是弄的这玩意 ;command=/bin/eventlistener ; 这个和上面的program一样，表示listener的可执行文件的路径 ;process_name=%(program_name)s ; 这个也一样，进程名，当下面的numprocs为多个的时候，才需要。否则默认就 OK了 ;numprocs=1 ; 相同的listener启动的个数 ;events=EVENT ; event事件的类型，也就是说，只有写在这个地方的事件类型。才会被发送 ;buffer_size=10 ; 这个是event队列缓存大小，单位不太清楚，楼主猜测应该是个吧。当buffer 超过10的时候，最旧的event将会被清除，并把新的event放进去。 默认值为10。。非必须选项 ;directory=/tmp ; 进程执行前，会切换到这个目录下执行 默认为不切换。。。非必须 ;umask=022 ; 淹没，默认为none，不说了 ;priority=-1 ; 启动优先级，默认-1，也不扯了 ;autostart=true ; 是否随supervisord启动一起启动，默认true ;autorestart=unexpected ; 是否自动重启，和program一个样，分true,false,unexpected等，注意 unexpected和exitcodes的关系 ;startsecs=1 ; 也是一样，进程启动后跑了几秒钟，才被认定为成功启动，默认1 ;startretries=3 ; 失败最大尝试次数，默认3 ;exitcodes=0,2 ; 期望或者说预料中的进程退出码， ;stopsignal=QUIT ; 干掉进程的信号，默认为TERM，比如设置为QUIT，那么如果QUIT来干这个进程 那么会被认为是正常维护，退出码也被认为是expected中的 ;stopwaitsecs=10 ; max num secs to wait b4 SIGKILL (default 10) ;stopasgroup=false ; send stop signal to the UNIX process group (default false) ;killasgroup=false ; SIGKILL the UNIX process group (def false) ;user=chrism ;设置普通用户，可以用来管理该listener进程。 默认为空。。非必须设置 ;redirect_stderr=true ; 为true的话，stderr的log会并入stdout的log里面 默认为false。。。非必须设置 ;stdout_logfile=/a/path ; 这个不说了，好几遍了 ;stdout_logfile_maxbytes=1MB ; 这个也是 ;stdout_logfile_backups=10 ; 这个也是 ;stdout_events_enabled=false ; 这个其实是错的，listener是不能发送event ;stderr_logfile=/a/path ; 这个也是 ;stderr_logfile_maxbytes=1MB ; 这个也是 ;stderr_logfile_backups ; 这个不说了 ;stderr_events_enabled=false ; 这个也是错的，listener不能发送event ;environment=A=”1”,B=”2” ; 这个是该子进程的环境变量 默认为空。。。非必须设置 ;serverurl=AUTO ; override serverurl computation (childutils) ; The below sample group section shows all possible group values, ; create one or more ‘real’ group: sections to create “heterogeneous” ; process groups. ;[group:thegroupname] ;这个东西就是给programs分组，划分到组里面的program。我们就不用一个一个去操作了 我们可以对组名进行统一的操作。 注意：program被划分到组里面之后，就相当于原来 的配置从supervisor的配置文件里消失了。。。supervisor只会对组进行管理，而不再 会对组里面的单个program进行管理了 ;programs=progname1,progname2 ; 组成员，用逗号分开 这个是个必须的设置项 ;priority=999 ; 优先级，相对于组和组之间说的 默认999。。非必须选项 ; The [include] section can just contain the “files” setting. This ; setting can list multiple files (separated by whitespace or ; newlines). It can also contain wildcards. The filenames are ; interpreted as relative to this file. Included files *cannot* ; include files themselves. ;[include] ;这个东西挺有用的，当我们要管理的进程很多的时候，写在一个文件里面 就有点大了。我们可以把配置信息写到多个文件中，然后include过来 ;files = relative/directory/*.ini [/bash] 参考: <a href="http://lixcto.blog.51cto.com/4834175/1539136" target="_blank" rel="noopener">http://lixcto.blog.51cto.com/4834175/1539136</a></topic></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Supervisor 是基于 Python 的进程管理工具，只能运行在 Unix-Like 的系统上,Supervisor可以很方便的用来启动、重启、关闭进程。除了对单个进程的控制，还可以同时启动、关闭多个进程。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.ichenfei.com/categories/Linux/"/>
    
      <category term="Python" scheme="http://blog.ichenfei.com/categories/Linux/Python/"/>
    
    
      <category term="supervisor" scheme="http://blog.ichenfei.com/tags/supervisor/"/>
    
      <category term="管理Linux进程" scheme="http://blog.ichenfei.com/tags/%E7%AE%A1%E7%90%86Linux%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
</feed>
